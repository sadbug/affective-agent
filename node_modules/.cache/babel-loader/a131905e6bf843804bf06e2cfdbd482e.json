{"ast":null,"code":"const Utils = require(\"./util\");\n\nconst pth = require(\"path\");\n\nconst ZipEntry = require(\"./zipEntry\");\n\nconst ZipFile = require(\"./zipFile\");\n\nconst get_Bool = (val, def) => typeof val === \"boolean\" ? val : def;\n\nconst get_Str = (val, def) => typeof val === \"string\" ? val : def;\n\nconst defaultOptions = {\n  // option \"noSort\" : if true it disables files sorting\n  noSort: false,\n  // read entries during load (initial loading may be slower)\n  readEntries: false,\n  // default method is none\n  method: Utils.Constants.NONE,\n  // file system\n  fs: null\n};\n\nmodule.exports = function (\n/**String*/\ninput,\n/** object */\noptions) {\n  let inBuffer = null; // create object based default options, allowing them to be overwritten\n\n  const opts = Object.assign(Object.create(null), defaultOptions); // test input variable\n\n  if (input && \"object\" === typeof input) {\n    // if value is not buffer we accept it to be object with options\n    if (!(input instanceof Uint8Array)) {\n      Object.assign(opts, input);\n      input = opts.input ? opts.input : undefined;\n      if (opts.input) delete opts.input;\n    } // if input is buffer\n\n\n    if (Buffer.isBuffer(input)) {\n      inBuffer = input;\n      opts.method = Utils.Constants.BUFFER;\n      input = undefined;\n    }\n  } // assign options\n\n\n  Object.assign(opts, options); // instanciate utils filesystem\n\n  const filetools = new Utils(opts); // if input is file name we retrieve its content\n\n  if (input && \"string\" === typeof input) {\n    // load zip file\n    if (filetools.fs.existsSync(input)) {\n      opts.method = Utils.Constants.FILE;\n      opts.filename = input;\n      inBuffer = filetools.fs.readFileSync(input);\n    } else {\n      throw new Error(Utils.Errors.INVALID_FILENAME);\n    }\n  } // create variable\n\n\n  const _zip = new ZipFile(inBuffer, opts);\n\n  const {\n    canonical,\n    sanitize\n  } = Utils;\n\n  function getEntry(\n  /**Object*/\n  entry) {\n    if (entry && _zip) {\n      var item; // If entry was given as a file name\n\n      if (typeof entry === \"string\") item = _zip.getEntry(entry); // if entry was given as a ZipEntry object\n\n      if (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\") item = _zip.getEntry(entry.entryName);\n\n      if (item) {\n        return item;\n      }\n    }\n\n    return null;\n  }\n\n  function fixPath(zipPath) {\n    const {\n      join,\n      normalize,\n      sep\n    } = pth.posix; // convert windows file separators and normalize\n\n    return join(\".\", normalize(sep + zipPath.split(\"\\\\\").join(sep) + sep));\n  }\n\n  return {\n    /**\n     * Extracts the given entry from the archive and returns the content as a Buffer object\n     * @param entry ZipEntry object or String with the full path of the entry\n     *\n     * @return Buffer or Null in case of error\n     */\n    readFile: function (\n    /**Object*/\n    entry,\n    /*String, Buffer*/\n    pass) {\n      var item = getEntry(entry);\n      return item && item.getData(pass) || null;\n    },\n\n    /**\n     * Asynchronous readFile\n     * @param entry ZipEntry object or String with the full path of the entry\n     * @param callback\n     *\n     * @return Buffer or Null in case of error\n     */\n    readFileAsync: function (\n    /**Object*/\n    entry,\n    /**Function*/\n    callback) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.getDataAsync(callback);\n      } else {\n        callback(null, \"getEntry failed for:\" + entry);\n      }\n    },\n\n    /**\n     * Extracts the given entry from the archive and returns the content as plain text in the given encoding\n     * @param entry ZipEntry object or String with the full path of the entry\n     * @param encoding Optional. If no encoding is specified utf8 is used\n     *\n     * @return String\n     */\n    readAsText: function (\n    /**Object*/\n    entry,\n    /**String=*/\n    encoding) {\n      var item = getEntry(entry);\n\n      if (item) {\n        var data = item.getData();\n\n        if (data && data.length) {\n          return data.toString(encoding || \"utf8\");\n        }\n      }\n\n      return \"\";\n    },\n\n    /**\n     * Asynchronous readAsText\n     * @param entry ZipEntry object or String with the full path of the entry\n     * @param callback\n     * @param encoding Optional. If no encoding is specified utf8 is used\n     *\n     * @return String\n     */\n    readAsTextAsync: function (\n    /**Object*/\n    entry,\n    /**Function*/\n    callback,\n    /**String=*/\n    encoding) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.getDataAsync(function (data, err) {\n          if (err) {\n            callback(data, err);\n            return;\n          }\n\n          if (data && data.length) {\n            callback(data.toString(encoding || \"utf8\"));\n          } else {\n            callback(\"\");\n          }\n        });\n      } else {\n        callback(\"\");\n      }\n    },\n\n    /**\n     * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\n     *\n     * @param entry\n     */\n    deleteFile: function (\n    /**Object*/\n    entry) {\n      // @TODO: test deleteFile\n      var item = getEntry(entry);\n\n      if (item) {\n        _zip.deleteEntry(item.entryName);\n      }\n    },\n\n    /**\n     * Adds a comment to the zip. The zip must be rewritten after adding the comment.\n     *\n     * @param comment\n     */\n    addZipComment: function (\n    /**String*/\n    comment) {\n      // @TODO: test addZipComment\n      _zip.comment = comment;\n    },\n\n    /**\n     * Returns the zip comment\n     *\n     * @return String\n     */\n    getZipComment: function () {\n      return _zip.comment || \"\";\n    },\n\n    /**\n     * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\n     * The comment cannot exceed 65535 characters in length\n     *\n     * @param entry\n     * @param comment\n     */\n    addZipEntryComment: function (\n    /**Object*/\n    entry,\n    /**String*/\n    comment) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.comment = comment;\n      }\n    },\n\n    /**\n     * Returns the comment of the specified entry\n     *\n     * @param entry\n     * @return String\n     */\n    getZipEntryComment: function (\n    /**Object*/\n    entry) {\n      var item = getEntry(entry);\n\n      if (item) {\n        return item.comment || \"\";\n      }\n\n      return \"\";\n    },\n\n    /**\n     * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\n     *\n     * @param entry\n     * @param content\n     */\n    updateFile: function (\n    /**Object*/\n    entry,\n    /**Buffer*/\n    content) {\n      var item = getEntry(entry);\n\n      if (item) {\n        item.setData(content);\n      }\n    },\n\n    /**\n     * Adds a file from the disk to the archive\n     *\n     * @param localPath File to add to zip\n     * @param zipPath Optional path inside the zip\n     * @param zipName Optional name for the file\n     */\n    addLocalFile: function (\n    /**String*/\n    localPath,\n    /**String=*/\n    zipPath,\n    /**String=*/\n    zipName,\n    /**String*/\n    comment) {\n      if (filetools.fs.existsSync(localPath)) {\n        // fix ZipPath\n        zipPath = zipPath ? fixPath(zipPath) : \"\"; // p - local file name\n\n        var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop(); // add file name into zippath\n\n        zipPath += zipName ? zipName : p; // read file attributes\n\n        const _attr = filetools.fs.statSync(localPath); // add file into zip file\n\n\n        this.addFile(zipPath, filetools.fs.readFileSync(localPath), comment, _attr);\n      } else {\n        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n      }\n    },\n\n    /**\n     * Adds a local directory and all its nested files and directories to the archive\n     *\n     * @param localPath\n     * @param zipPath optional path inside zip\n     * @param filter optional RegExp or Function if files match will\n     *               be included.\n     */\n    addLocalFolder: function (\n    /**String*/\n    localPath,\n    /**String=*/\n    zipPath,\n    /**=RegExp|Function*/\n    filter) {\n      // Prepare filter\n      if (filter instanceof RegExp) {\n        // if filter is RegExp wrap it\n        filter = function (rx) {\n          return function (filename) {\n            return rx.test(filename);\n          };\n        }(filter);\n      } else if (\"function\" !== typeof filter) {\n        // if filter is not function we will replace it\n        filter = function () {\n          return true;\n        };\n      } // fix ZipPath\n\n\n      zipPath = zipPath ? fixPath(zipPath) : \"\"; // normalize the path first\n\n      localPath = pth.normalize(localPath);\n\n      if (filetools.fs.existsSync(localPath)) {\n        const items = filetools.findFiles(localPath);\n        const self = this;\n\n        if (items.length) {\n          items.forEach(function (filepath) {\n            var p = pth.relative(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n\n            if (filter(p)) {\n              var stats = filetools.fs.statSync(filepath);\n\n              if (stats.isFile()) {\n                self.addFile(zipPath + p, filetools.fs.readFileSync(filepath), \"\", stats);\n              } else {\n                self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", stats);\n              }\n            }\n          });\n        }\n      } else {\n        throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n      }\n    },\n\n    /**\n     * Asynchronous addLocalFile\n     * @param localPath\n     * @param callback\n     * @param zipPath optional path inside zip\n     * @param filter optional RegExp or Function if files match will\n     *               be included.\n     */\n    addLocalFolderAsync: function (\n    /*String*/\n    localPath,\n    /*Function*/\n    callback,\n    /*String*/\n    zipPath,\n    /*RegExp|Function*/\n    filter) {\n      if (filter instanceof RegExp) {\n        filter = function (rx) {\n          return function (filename) {\n            return rx.test(filename);\n          };\n        }(filter);\n      } else if (\"function\" !== typeof filter) {\n        filter = function () {\n          return true;\n        };\n      } // fix ZipPath\n\n\n      zipPath = zipPath ? fixPath(zipPath) : \"\"; // normalize the path first\n\n      localPath = pth.normalize(localPath);\n      var self = this;\n      filetools.fs.open(localPath, \"r\", function (err) {\n        if (err && err.code === \"ENOENT\") {\n          callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n        } else if (err) {\n          callback(undefined, err);\n        } else {\n          var items = filetools.findFiles(localPath);\n          var i = -1;\n\n          var next = function () {\n            i += 1;\n\n            if (i < items.length) {\n              var filepath = items[i];\n              var p = pth.relative(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n\n              p = p.normalize(\"NFD\").replace(/[\\u0300-\\u036f]/g, \"\").replace(/[^\\x20-\\x7E]/g, \"\"); // accent fix\n\n              if (filter(p)) {\n                filetools.fs.stat(filepath, function (er0, stats) {\n                  if (er0) callback(undefined, er0);\n\n                  if (stats.isFile()) {\n                    filetools.fs.readFile(filepath, function (er1, data) {\n                      if (er1) {\n                        callback(undefined, er1);\n                      } else {\n                        self.addFile(zipPath + p, data, \"\", stats);\n                        next();\n                      }\n                    });\n                  } else {\n                    self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", stats);\n                    next();\n                  }\n                });\n              } else {\n                next();\n              }\n            } else {\n              callback(true, undefined);\n            }\n          };\n\n          next();\n        }\n      });\n    },\n\n    /**\n     *\n     * @param {string} localPath - path where files will be extracted\n     * @param {object} props - optional properties\n     * @param {string} props.zipPath - optional path inside zip\n     * @param {regexp, function} props.filter - RegExp or Function if files match will be included.\n     */\n    addLocalFolderPromise: function (\n    /*String*/\n    localPath,\n    /* object */\n    props) {\n      return new Promise((resolve, reject) => {\n        const {\n          filter,\n          zipPath\n        } = Object.assign({}, props);\n        this.addLocalFolderAsync(localPath, (done, err) => {\n          if (err) reject(err);\n          if (done) resolve(this);\n        }, zipPath, filter);\n      });\n    },\n\n    /**\n     * Allows you to create a entry (file or directory) in the zip file.\n     * If you want to create a directory the entryName must end in / and a null buffer should be provided.\n     * Comment and attributes are optional\n     *\n     * @param {string} entryName\n     * @param {Buffer | string} content - file content as buffer or utf8 coded string\n     * @param {string} comment - file comment\n     * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object\n     */\n    addFile: function (\n    /**String*/\n    entryName,\n    /**Buffer*/\n    content,\n    /**String*/\n    comment,\n    /**Number*/\n    attr) {\n      let entry = getEntry(entryName);\n      const update = entry != null; // prepare new entry\n\n      if (!update) {\n        entry = new ZipEntry();\n        entry.entryName = entryName;\n      }\n\n      entry.comment = comment || \"\";\n      const isStat = \"object\" === typeof attr && attr instanceof filetools.fs.Stats; // last modification time from file stats\n\n      if (isStat) {\n        entry.header.time = attr.mtime;\n      } // Set file attribute\n\n\n      var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)\n      // extended attributes field for Unix\n\n      if (!Utils.isWin) {\n        // set file type either S_IFDIR / S_IFREG\n        let unix = entry.isDirectory ? 0x4000 : 0x8000;\n\n        if (isStat) {\n          // File attributes from file stats\n          unix |= 0xfff & attr.mode;\n        } else if (\"number\" === typeof attr) {\n          // attr from given attr values\n          unix |= 0xfff & attr;\n        } else {\n          // Default values:\n          unix |= entry.isDirectory ? 0o755 : 0o644; // permissions (drwxr-xr-x) or (-r-wr--r--)\n        }\n\n        fileattr = (fileattr | unix << 16) >>> 0; // add attributes\n      }\n\n      entry.attr = fileattr;\n      entry.setData(content);\n      if (!update) _zip.setEntry(entry);\n    },\n\n    /**\n     * Returns an array of ZipEntry objects representing the files and folders inside the archive\n     *\n     * @return Array\n     */\n    getEntries: function () {\n      return _zip ? _zip.entries : [];\n    },\n\n    /**\n     * Returns a ZipEntry object representing the file or folder specified by ``name``.\n     *\n     * @param name\n     * @return ZipEntry\n     */\n    getEntry: function (\n    /**String*/\n    name) {\n      return getEntry(name);\n    },\n    getEntryCount: function () {\n      return _zip.getEntryCount();\n    },\n    forEach: function (callback) {\n      return _zip.forEach(callback);\n    },\n\n    /**\n     * Extracts the given entry to the given targetPath\n     * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\n     *\n     * @param entry ZipEntry object or String with the full path of the entry\n     * @param targetPath Target folder where to write the file\n     * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\n     *                          will be created in targetPath as well. Default is TRUE\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n     *                  Default is FALSE\n     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n     *                  Default is FALSE\n     * @param outFileName String If set will override the filename of the extracted file (Only works if the entry is a file)\n     *\n     * @return Boolean\n     */\n    extractEntryTo: function (\n    /**Object*/\n    entry,\n    /**String*/\n    targetPath,\n    /**Boolean*/\n    maintainEntryPath,\n    /**Boolean*/\n    overwrite,\n    /**Boolean*/\n    keepOriginalPermission,\n    /**String**/\n    outFileName) {\n      overwrite = get_Bool(overwrite, false);\n      keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n      maintainEntryPath = get_Bool(maintainEntryPath, true);\n      outFileName = get_Str(outFileName, get_Str(keepOriginalPermission, undefined));\n      var item = getEntry(entry);\n\n      if (!item) {\n        throw new Error(Utils.Errors.NO_ENTRY);\n      }\n\n      var entryName = canonical(item.entryName);\n      var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));\n\n      if (item.isDirectory) {\n        var children = _zip.getEntryChildren(item);\n\n        children.forEach(function (child) {\n          if (child.isDirectory) return;\n          var content = child.getData();\n\n          if (!content) {\n            throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n          }\n\n          var name = canonical(child.entryName);\n          var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name)); // The reverse operation for attr depend on method addFile()\n\n          const fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;\n          filetools.writeFileTo(childName, content, overwrite, fileAttr);\n        });\n        return true;\n      }\n\n      var content = item.getData();\n      if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n\n      if (filetools.fs.existsSync(target) && !overwrite) {\n        throw new Error(Utils.Errors.CANT_OVERRIDE);\n      } // The reverse operation for attr depend on method addFile()\n\n\n      const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n      filetools.writeFileTo(target, content, overwrite, fileAttr);\n      return true;\n    },\n\n    /**\n     * Test the archive\n     *\n     */\n    test: function (pass) {\n      if (!_zip) {\n        return false;\n      }\n\n      for (var entry in _zip.entries) {\n        try {\n          if (entry.isDirectory) {\n            continue;\n          }\n\n          var content = _zip.entries[entry].getData(pass);\n\n          if (!content) {\n            return false;\n          }\n        } catch (err) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Extracts the entire archive to the given location\n     *\n     * @param targetPath Target location\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n     *                  Default is FALSE\n     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n     *                  Default is FALSE\n     */\n    extractAllTo: function (\n    /**String*/\n    targetPath,\n    /**Boolean*/\n    overwrite,\n    /**Boolean*/\n    keepOriginalPermission,\n    /*String, Buffer*/\n    pass) {\n      overwrite = get_Bool(overwrite, false);\n      pass = get_Str(keepOriginalPermission, pass);\n      keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n\n      if (!_zip) {\n        throw new Error(Utils.Errors.NO_ZIP);\n      }\n\n      _zip.entries.forEach(function (entry) {\n        var entryName = sanitize(targetPath, canonical(entry.entryName.toString()));\n\n        if (entry.isDirectory) {\n          filetools.makeDir(entryName);\n          return;\n        }\n\n        var content = entry.getData(pass);\n\n        if (!content) {\n          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n        } // The reverse operation for attr depend on method addFile()\n\n\n        const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n        filetools.writeFileTo(entryName, content, overwrite, fileAttr);\n\n        try {\n          filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);\n        } catch (err) {\n          throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n        }\n      });\n    },\n\n    /**\n     * Asynchronous extractAllTo\n     *\n     * @param targetPath Target location\n     * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n     *                  Default is FALSE\n     * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n     *                  Default is FALSE\n     * @param callback The callback will be executed when all entries are extracted successfully or any error is thrown.\n     */\n    extractAllToAsync: function (\n    /**String*/\n    targetPath,\n    /**Boolean*/\n    overwrite,\n    /**Boolean*/\n    keepOriginalPermission,\n    /**Function*/\n    callback) {\n      if (!callback) {\n        callback = function () {};\n      }\n\n      overwrite = get_Bool(overwrite, false);\n      if (typeof keepOriginalPermission === \"function\" && !callback) callback = keepOriginalPermission;\n      keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n\n      if (!_zip) {\n        callback(new Error(Utils.Errors.NO_ZIP));\n        return;\n      }\n\n      targetPath = pth.resolve(targetPath); // convert entryName to\n\n      const getPath = entry => sanitize(targetPath, pth.normalize(canonical(entry.entryName.toString())));\n\n      const getError = (msg, file) => new Error(msg + ': \"' + file + '\"'); // separate directories from files\n\n\n      const dirEntries = [];\n      const fileEntries = new Set();\n\n      _zip.entries.forEach(e => {\n        if (e.isDirectory) {\n          dirEntries.push(e);\n        } else {\n          fileEntries.add(e);\n        }\n      }); // Create directory entries first synchronously\n      // this prevents race condition and assures folders are there before writing files\n\n\n      for (const entry of dirEntries) {\n        const dirPath = getPath(entry); // The reverse operation for attr depend on method addFile()\n\n        const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n\n        try {\n          filetools.makeDir(dirPath);\n          if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr); // in unix timestamp will change if files are later added to folder, but still\n\n          filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);\n        } catch (er) {\n          callback(getError(\"Unable to create folder\", dirPath));\n        }\n      } // callback wrapper, for some house keeping\n\n\n      const done = () => {\n        if (fileEntries.size === 0) {\n          callback();\n        }\n      }; // Extract file entries asynchronously\n\n\n      for (const entry of fileEntries.values()) {\n        const entryName = pth.normalize(canonical(entry.entryName.toString()));\n        const filePath = sanitize(targetPath, entryName);\n        entry.getDataAsync(function (content, err_1) {\n          if (err_1) {\n            callback(new Error(err_1));\n            return;\n          }\n\n          if (!content) {\n            callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\n          } else {\n            // The reverse operation for attr depend on method addFile()\n            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n            filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {\n              if (!succ) {\n                callback(getError(\"Unable to write file\", filePath));\n                return;\n              }\n\n              filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {\n                if (err_2) {\n                  callback(getError(\"Unable to set times\", filePath));\n                  return;\n                }\n\n                fileEntries.delete(entry); // call the callback if it was last entry\n\n                done();\n              });\n            });\n          }\n        });\n      } // call the callback if fileEntries was empty\n\n\n      done();\n    },\n\n    /**\n     * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\n     *\n     * @param targetFileName\n     * @param callback\n     */\n    writeZip: function (\n    /**String*/\n    targetFileName,\n    /**Function*/\n    callback) {\n      if (arguments.length === 1) {\n        if (typeof targetFileName === \"function\") {\n          callback = targetFileName;\n          targetFileName = \"\";\n        }\n      }\n\n      if (!targetFileName && opts.filename) {\n        targetFileName = opts.filename;\n      }\n\n      if (!targetFileName) return;\n\n      var zipData = _zip.compressToBuffer();\n\n      if (zipData) {\n        var ok = filetools.writeFileTo(targetFileName, zipData, true);\n        if (typeof callback === \"function\") callback(!ok ? new Error(\"failed\") : null, \"\");\n      }\n    },\n    writeZipPromise: function (\n    /**String*/\n    targetFileName,\n    /* object */\n    props) {\n      const {\n        overwrite,\n        perm\n      } = Object.assign({\n        overwrite: true\n      }, props);\n      return new Promise((resolve, reject) => {\n        // find file name\n        if (!targetFileName && opts.filename) targetFileName = opts.filename;\n        if (!targetFileName) reject(\"ADM-ZIP: ZIP File Name Missing\");\n        this.toBufferPromise().then(zipData => {\n          const ret = done => done ? resolve(done) : reject(\"ADM-ZIP: Wasn't able to write zip file\");\n\n          filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);\n        }, reject);\n      });\n    },\n    toBufferPromise: function () {\n      return new Promise((resolve, reject) => {\n        _zip.toAsyncBuffer(resolve, reject);\n      });\n    },\n\n    /**\n     * Returns the content of the entire zip file as a Buffer object\n     *\n     * @return Buffer\n     */\n    toBuffer: function (\n    /**Function=*/\n    onSuccess,\n    /**Function=*/\n    onFail,\n    /**Function=*/\n    onItemStart,\n    /**Function=*/\n    onItemEnd) {\n      this.valueOf = 2;\n\n      if (typeof onSuccess === \"function\") {\n        _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n\n        return null;\n      }\n\n      return _zip.compressToBuffer();\n    }\n  };\n};","map":{"version":3,"names":["Utils","require","pth","ZipEntry","ZipFile","get_Bool","val","def","get_Str","defaultOptions","noSort","readEntries","method","Constants","NONE","fs","module","exports","input","options","inBuffer","opts","Object","assign","create","Uint8Array","undefined","Buffer","isBuffer","BUFFER","filetools","existsSync","FILE","filename","readFileSync","Error","Errors","INVALID_FILENAME","_zip","canonical","sanitize","getEntry","entry","item","entryName","header","fixPath","zipPath","join","normalize","sep","posix","split","readFile","pass","getData","readFileAsync","callback","getDataAsync","readAsText","encoding","data","length","toString","readAsTextAsync","err","deleteFile","deleteEntry","addZipComment","comment","getZipComment","addZipEntryComment","getZipEntryComment","updateFile","content","setData","addLocalFile","localPath","zipName","p","pop","_attr","statSync","addFile","FILE_NOT_FOUND","replace","addLocalFolder","filter","RegExp","rx","test","items","findFiles","self","forEach","filepath","relative","stats","isFile","alloc","addLocalFolderAsync","open","code","i","next","stat","er0","er1","addLocalFolderPromise","props","Promise","resolve","reject","done","attr","update","isStat","Stats","time","mtime","fileattr","isDirectory","isWin","unix","mode","setEntry","getEntries","entries","name","getEntryCount","extractEntryTo","targetPath","maintainEntryPath","overwrite","keepOriginalPermission","outFileName","NO_ENTRY","target","basename","children","getEntryChildren","child","CANT_EXTRACT_FILE","childName","fileAttr","writeFileTo","CANT_OVERRIDE","extractAllTo","NO_ZIP","makeDir","utimesSync","extractAllToAsync","getPath","getError","msg","file","dirEntries","fileEntries","Set","e","push","add","dirPath","dirAttr","chmodSync","er","size","values","filePath","err_1","writeFileToAsync","succ","utimes","err_2","delete","writeZip","targetFileName","arguments","zipData","compressToBuffer","ok","writeZipPromise","perm","toBufferPromise","then","ret","toAsyncBuffer","toBuffer","onSuccess","onFail","onItemStart","onItemEnd","valueOf"],"sources":["/Users/andrejsmolencev/Desktop/scorm-generator/node_modules/adm-zip/adm-zip.js"],"sourcesContent":["const Utils = require(\"./util\");\nconst pth = require(\"path\");\nconst ZipEntry = require(\"./zipEntry\");\nconst ZipFile = require(\"./zipFile\");\n\nconst get_Bool = (val, def) => (typeof val === \"boolean\" ? val : def);\nconst get_Str = (val, def) => (typeof val === \"string\" ? val : def);\n\nconst defaultOptions = {\n    // option \"noSort\" : if true it disables files sorting\n    noSort: false,\n    // read entries during load (initial loading may be slower)\n    readEntries: false,\n    // default method is none\n    method: Utils.Constants.NONE,\n    // file system\n    fs: null\n};\n\nmodule.exports = function (/**String*/ input, /** object */ options) {\n    let inBuffer = null;\n\n    // create object based default options, allowing them to be overwritten\n    const opts = Object.assign(Object.create(null), defaultOptions);\n\n    // test input variable\n    if (input && \"object\" === typeof input) {\n        // if value is not buffer we accept it to be object with options\n        if (!(input instanceof Uint8Array)) {\n            Object.assign(opts, input);\n            input = opts.input ? opts.input : undefined;\n            if (opts.input) delete opts.input;\n        }\n\n        // if input is buffer\n        if (Buffer.isBuffer(input)) {\n            inBuffer = input;\n            opts.method = Utils.Constants.BUFFER;\n            input = undefined;\n        }\n    }\n\n    // assign options\n    Object.assign(opts, options);\n\n    // instanciate utils filesystem\n    const filetools = new Utils(opts);\n\n    // if input is file name we retrieve its content\n    if (input && \"string\" === typeof input) {\n        // load zip file\n        if (filetools.fs.existsSync(input)) {\n            opts.method = Utils.Constants.FILE;\n            opts.filename = input;\n            inBuffer = filetools.fs.readFileSync(input);\n        } else {\n            throw new Error(Utils.Errors.INVALID_FILENAME);\n        }\n    }\n\n    // create variable\n    const _zip = new ZipFile(inBuffer, opts);\n\n    const { canonical, sanitize } = Utils;\n\n    function getEntry(/**Object*/ entry) {\n        if (entry && _zip) {\n            var item;\n            // If entry was given as a file name\n            if (typeof entry === \"string\") item = _zip.getEntry(entry);\n            // if entry was given as a ZipEntry object\n            if (typeof entry === \"object\" && typeof entry.entryName !== \"undefined\" && typeof entry.header !== \"undefined\") item = _zip.getEntry(entry.entryName);\n\n            if (item) {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    function fixPath(zipPath) {\n        const { join, normalize, sep } = pth.posix;\n        // convert windows file separators and normalize\n        return join(\".\", normalize(sep + zipPath.split(\"\\\\\").join(sep) + sep));\n    }\n\n    return {\n        /**\n         * Extracts the given entry from the archive and returns the content as a Buffer object\n         * @param entry ZipEntry object or String with the full path of the entry\n         *\n         * @return Buffer or Null in case of error\n         */\n        readFile: function (/**Object*/ entry, /*String, Buffer*/ pass) {\n            var item = getEntry(entry);\n            return (item && item.getData(pass)) || null;\n        },\n\n        /**\n         * Asynchronous readFile\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param callback\n         *\n         * @return Buffer or Null in case of error\n         */\n        readFileAsync: function (/**Object*/ entry, /**Function*/ callback) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(callback);\n            } else {\n                callback(null, \"getEntry failed for:\" + entry);\n            }\n        },\n\n        /**\n         * Extracts the given entry from the archive and returns the content as plain text in the given encoding\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param encoding Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */\n        readAsText: function (/**Object*/ entry, /**String=*/ encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                var data = item.getData();\n                if (data && data.length) {\n                    return data.toString(encoding || \"utf8\");\n                }\n            }\n            return \"\";\n        },\n\n        /**\n         * Asynchronous readAsText\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param callback\n         * @param encoding Optional. If no encoding is specified utf8 is used\n         *\n         * @return String\n         */\n        readAsTextAsync: function (/**Object*/ entry, /**Function*/ callback, /**String=*/ encoding) {\n            var item = getEntry(entry);\n            if (item) {\n                item.getDataAsync(function (data, err) {\n                    if (err) {\n                        callback(data, err);\n                        return;\n                    }\n\n                    if (data && data.length) {\n                        callback(data.toString(encoding || \"utf8\"));\n                    } else {\n                        callback(\"\");\n                    }\n                });\n            } else {\n                callback(\"\");\n            }\n        },\n\n        /**\n         * Remove the entry from the file or the entry and all it's nested directories and files if the given entry is a directory\n         *\n         * @param entry\n         */\n        deleteFile: function (/**Object*/ entry) {\n            // @TODO: test deleteFile\n            var item = getEntry(entry);\n            if (item) {\n                _zip.deleteEntry(item.entryName);\n            }\n        },\n\n        /**\n         * Adds a comment to the zip. The zip must be rewritten after adding the comment.\n         *\n         * @param comment\n         */\n        addZipComment: function (/**String*/ comment) {\n            // @TODO: test addZipComment\n            _zip.comment = comment;\n        },\n\n        /**\n         * Returns the zip comment\n         *\n         * @return String\n         */\n        getZipComment: function () {\n            return _zip.comment || \"\";\n        },\n\n        /**\n         * Adds a comment to a specified zipEntry. The zip must be rewritten after adding the comment\n         * The comment cannot exceed 65535 characters in length\n         *\n         * @param entry\n         * @param comment\n         */\n        addZipEntryComment: function (/**Object*/ entry, /**String*/ comment) {\n            var item = getEntry(entry);\n            if (item) {\n                item.comment = comment;\n            }\n        },\n\n        /**\n         * Returns the comment of the specified entry\n         *\n         * @param entry\n         * @return String\n         */\n        getZipEntryComment: function (/**Object*/ entry) {\n            var item = getEntry(entry);\n            if (item) {\n                return item.comment || \"\";\n            }\n            return \"\";\n        },\n\n        /**\n         * Updates the content of an existing entry inside the archive. The zip must be rewritten after updating the content\n         *\n         * @param entry\n         * @param content\n         */\n        updateFile: function (/**Object*/ entry, /**Buffer*/ content) {\n            var item = getEntry(entry);\n            if (item) {\n                item.setData(content);\n            }\n        },\n\n        /**\n         * Adds a file from the disk to the archive\n         *\n         * @param localPath File to add to zip\n         * @param zipPath Optional path inside the zip\n         * @param zipName Optional name for the file\n         */\n        addLocalFile: function (/**String*/ localPath, /**String=*/ zipPath, /**String=*/ zipName, /**String*/ comment) {\n            if (filetools.fs.existsSync(localPath)) {\n                // fix ZipPath\n                zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n                // p - local file name\n                var p = localPath.split(\"\\\\\").join(\"/\").split(\"/\").pop();\n\n                // add file name into zippath\n                zipPath += zipName ? zipName : p;\n\n                // read file attributes\n                const _attr = filetools.fs.statSync(localPath);\n\n                // add file into zip file\n                this.addFile(zipPath, filetools.fs.readFileSync(localPath), comment, _attr);\n            } else {\n                throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n            }\n        },\n\n        /**\n         * Adds a local directory and all its nested files and directories to the archive\n         *\n         * @param localPath\n         * @param zipPath optional path inside zip\n         * @param filter optional RegExp or Function if files match will\n         *               be included.\n         */\n        addLocalFolder: function (/**String*/ localPath, /**String=*/ zipPath, /**=RegExp|Function*/ filter) {\n            // Prepare filter\n            if (filter instanceof RegExp) {\n                // if filter is RegExp wrap it\n                filter = (function (rx) {\n                    return function (filename) {\n                        return rx.test(filename);\n                    };\n                })(filter);\n            } else if (\"function\" !== typeof filter) {\n                // if filter is not function we will replace it\n                filter = function () {\n                    return true;\n                };\n            }\n\n            // fix ZipPath\n            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n            // normalize the path first\n            localPath = pth.normalize(localPath);\n\n            if (filetools.fs.existsSync(localPath)) {\n                const items = filetools.findFiles(localPath);\n                const self = this;\n\n                if (items.length) {\n                    items.forEach(function (filepath) {\n                        var p = pth.relative(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n                        if (filter(p)) {\n                            var stats = filetools.fs.statSync(filepath);\n                            if (stats.isFile()) {\n                                self.addFile(zipPath + p, filetools.fs.readFileSync(filepath), \"\", stats);\n                            } else {\n                                self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", stats);\n                            }\n                        }\n                    });\n                }\n            } else {\n                throw new Error(Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n            }\n        },\n\n        /**\n         * Asynchronous addLocalFile\n         * @param localPath\n         * @param callback\n         * @param zipPath optional path inside zip\n         * @param filter optional RegExp or Function if files match will\n         *               be included.\n         */\n        addLocalFolderAsync: function (/*String*/ localPath, /*Function*/ callback, /*String*/ zipPath, /*RegExp|Function*/ filter) {\n            if (filter instanceof RegExp) {\n                filter = (function (rx) {\n                    return function (filename) {\n                        return rx.test(filename);\n                    };\n                })(filter);\n            } else if (\"function\" !== typeof filter) {\n                filter = function () {\n                    return true;\n                };\n            }\n\n            // fix ZipPath\n            zipPath = zipPath ? fixPath(zipPath) : \"\";\n\n            // normalize the path first\n            localPath = pth.normalize(localPath);\n\n            var self = this;\n            filetools.fs.open(localPath, \"r\", function (err) {\n                if (err && err.code === \"ENOENT\") {\n                    callback(undefined, Utils.Errors.FILE_NOT_FOUND.replace(\"%s\", localPath));\n                } else if (err) {\n                    callback(undefined, err);\n                } else {\n                    var items = filetools.findFiles(localPath);\n                    var i = -1;\n\n                    var next = function () {\n                        i += 1;\n                        if (i < items.length) {\n                            var filepath = items[i];\n                            var p = pth.relative(localPath, filepath).split(\"\\\\\").join(\"/\"); //windows fix\n                            p = p\n                                .normalize(\"NFD\")\n                                .replace(/[\\u0300-\\u036f]/g, \"\")\n                                .replace(/[^\\x20-\\x7E]/g, \"\"); // accent fix\n                            if (filter(p)) {\n                                filetools.fs.stat(filepath, function (er0, stats) {\n                                    if (er0) callback(undefined, er0);\n                                    if (stats.isFile()) {\n                                        filetools.fs.readFile(filepath, function (er1, data) {\n                                            if (er1) {\n                                                callback(undefined, er1);\n                                            } else {\n                                                self.addFile(zipPath + p, data, \"\", stats);\n                                                next();\n                                            }\n                                        });\n                                    } else {\n                                        self.addFile(zipPath + p + \"/\", Buffer.alloc(0), \"\", stats);\n                                        next();\n                                    }\n                                });\n                            } else {\n                                next();\n                            }\n                        } else {\n                            callback(true, undefined);\n                        }\n                    };\n\n                    next();\n                }\n            });\n        },\n\n        /**\n         *\n         * @param {string} localPath - path where files will be extracted\n         * @param {object} props - optional properties\n         * @param {string} props.zipPath - optional path inside zip\n         * @param {regexp, function} props.filter - RegExp or Function if files match will be included.\n         */\n        addLocalFolderPromise: function (/*String*/ localPath, /* object */ props) {\n            return new Promise((resolve, reject) => {\n                const { filter, zipPath } = Object.assign({}, props);\n                this.addLocalFolderAsync(\n                    localPath,\n                    (done, err) => {\n                        if (err) reject(err);\n                        if (done) resolve(this);\n                    },\n                    zipPath,\n                    filter\n                );\n            });\n        },\n\n        /**\n         * Allows you to create a entry (file or directory) in the zip file.\n         * If you want to create a directory the entryName must end in / and a null buffer should be provided.\n         * Comment and attributes are optional\n         *\n         * @param {string} entryName\n         * @param {Buffer | string} content - file content as buffer or utf8 coded string\n         * @param {string} comment - file comment\n         * @param {number | object} attr - number as unix file permissions, object as filesystem Stats object\n         */\n        addFile: function (/**String*/ entryName, /**Buffer*/ content, /**String*/ comment, /**Number*/ attr) {\n            let entry = getEntry(entryName);\n            const update = entry != null;\n\n            // prepare new entry\n            if (!update) {\n                entry = new ZipEntry();\n                entry.entryName = entryName;\n            }\n            entry.comment = comment || \"\";\n\n            const isStat = \"object\" === typeof attr && attr instanceof filetools.fs.Stats;\n\n            // last modification time from file stats\n            if (isStat) {\n                entry.header.time = attr.mtime;\n            }\n\n            // Set file attribute\n            var fileattr = entry.isDirectory ? 0x10 : 0; // (MS-DOS directory flag)\n\n            // extended attributes field for Unix\n            if (!Utils.isWin) {\n                // set file type either S_IFDIR / S_IFREG\n                let unix = entry.isDirectory ? 0x4000 : 0x8000;\n\n                if (isStat) {\n                    // File attributes from file stats\n                    unix |= 0xfff & attr.mode;\n                } else if (\"number\" === typeof attr) {\n                    // attr from given attr values\n                    unix |= 0xfff & attr;\n                } else {\n                    // Default values:\n                    unix |= entry.isDirectory ? 0o755 : 0o644; // permissions (drwxr-xr-x) or (-r-wr--r--)\n                }\n\n                fileattr = (fileattr | (unix << 16)) >>> 0; // add attributes\n            }\n\n            entry.attr = fileattr;\n\n            entry.setData(content);\n            if (!update) _zip.setEntry(entry);\n        },\n\n        /**\n         * Returns an array of ZipEntry objects representing the files and folders inside the archive\n         *\n         * @return Array\n         */\n        getEntries: function () {\n            return _zip ? _zip.entries : [];\n        },\n\n        /**\n         * Returns a ZipEntry object representing the file or folder specified by ``name``.\n         *\n         * @param name\n         * @return ZipEntry\n         */\n        getEntry: function (/**String*/ name) {\n            return getEntry(name);\n        },\n\n        getEntryCount: function () {\n            return _zip.getEntryCount();\n        },\n\n        forEach: function (callback) {\n            return _zip.forEach(callback);\n        },\n\n        /**\n         * Extracts the given entry to the given targetPath\n         * If the entry is a directory inside the archive, the entire directory and it's subdirectories will be extracted\n         *\n         * @param entry ZipEntry object or String with the full path of the entry\n         * @param targetPath Target folder where to write the file\n         * @param maintainEntryPath If maintainEntryPath is true and the entry is inside a folder, the entry folder\n         *                          will be created in targetPath as well. Default is TRUE\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n         *                  Default is FALSE\n         * @param outFileName String If set will override the filename of the extracted file (Only works if the entry is a file)\n         *\n         * @return Boolean\n         */\n        extractEntryTo: function (\n            /**Object*/ entry,\n            /**String*/ targetPath,\n            /**Boolean*/ maintainEntryPath,\n            /**Boolean*/ overwrite,\n            /**Boolean*/ keepOriginalPermission,\n            /**String**/ outFileName\n        ) {\n            overwrite = get_Bool(overwrite, false);\n            keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n            maintainEntryPath = get_Bool(maintainEntryPath, true);\n            outFileName = get_Str(outFileName, get_Str(keepOriginalPermission, undefined));\n\n            var item = getEntry(entry);\n            if (!item) {\n                throw new Error(Utils.Errors.NO_ENTRY);\n            }\n\n            var entryName = canonical(item.entryName);\n\n            var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));\n\n            if (item.isDirectory) {\n                var children = _zip.getEntryChildren(item);\n                children.forEach(function (child) {\n                    if (child.isDirectory) return;\n                    var content = child.getData();\n                    if (!content) {\n                        throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n                    }\n                    var name = canonical(child.entryName);\n                    var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));\n                    // The reverse operation for attr depend on method addFile()\n                    const fileAttr = keepOriginalPermission ? child.header.fileAttr : undefined;\n                    filetools.writeFileTo(childName, content, overwrite, fileAttr);\n                });\n                return true;\n            }\n\n            var content = item.getData();\n            if (!content) throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n\n            if (filetools.fs.existsSync(target) && !overwrite) {\n                throw new Error(Utils.Errors.CANT_OVERRIDE);\n            }\n            // The reverse operation for attr depend on method addFile()\n            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n            filetools.writeFileTo(target, content, overwrite, fileAttr);\n\n            return true;\n        },\n\n        /**\n         * Test the archive\n         *\n         */\n        test: function (pass) {\n            if (!_zip) {\n                return false;\n            }\n\n            for (var entry in _zip.entries) {\n                try {\n                    if (entry.isDirectory) {\n                        continue;\n                    }\n                    var content = _zip.entries[entry].getData(pass);\n                    if (!content) {\n                        return false;\n                    }\n                } catch (err) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n         * Extracts the entire archive to the given location\n         *\n         * @param targetPath Target location\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n         *                  Default is FALSE\n         */\n        extractAllTo: function (/**String*/ targetPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /*String, Buffer*/ pass) {\n            overwrite = get_Bool(overwrite, false);\n            pass = get_Str(keepOriginalPermission, pass);\n            keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n            if (!_zip) {\n                throw new Error(Utils.Errors.NO_ZIP);\n            }\n            _zip.entries.forEach(function (entry) {\n                var entryName = sanitize(targetPath, canonical(entry.entryName.toString()));\n                if (entry.isDirectory) {\n                    filetools.makeDir(entryName);\n                    return;\n                }\n                var content = entry.getData(pass);\n                if (!content) {\n                    throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n                }\n                // The reverse operation for attr depend on method addFile()\n                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                filetools.writeFileTo(entryName, content, overwrite, fileAttr);\n                try {\n                    filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);\n                } catch (err) {\n                    throw new Error(Utils.Errors.CANT_EXTRACT_FILE);\n                }\n            });\n        },\n\n        /**\n         * Asynchronous extractAllTo\n         *\n         * @param targetPath Target location\n         * @param overwrite If the file already exists at the target path, the file will be overwriten if this is true.\n         *                  Default is FALSE\n         * @param keepOriginalPermission The file will be set as the permission from the entry if this is true.\n         *                  Default is FALSE\n         * @param callback The callback will be executed when all entries are extracted successfully or any error is thrown.\n         */\n        extractAllToAsync: function (/**String*/ targetPath, /**Boolean*/ overwrite, /**Boolean*/ keepOriginalPermission, /**Function*/ callback) {\n            if (!callback) {\n                callback = function () {};\n            }\n            overwrite = get_Bool(overwrite, false);\n            if (typeof keepOriginalPermission === \"function\" && !callback) callback = keepOriginalPermission;\n            keepOriginalPermission = get_Bool(keepOriginalPermission, false);\n            if (!_zip) {\n                callback(new Error(Utils.Errors.NO_ZIP));\n                return;\n            }\n\n            targetPath = pth.resolve(targetPath);\n            // convert entryName to\n            const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName.toString())));\n            const getError = (msg, file) => new Error(msg + ': \"' + file + '\"');\n\n            // separate directories from files\n            const dirEntries = [];\n            const fileEntries = new Set();\n            _zip.entries.forEach((e) => {\n                if (e.isDirectory) {\n                    dirEntries.push(e);\n                } else {\n                    fileEntries.add(e);\n                }\n            });\n\n            // Create directory entries first synchronously\n            // this prevents race condition and assures folders are there before writing files\n            for (const entry of dirEntries) {\n                const dirPath = getPath(entry);\n                // The reverse operation for attr depend on method addFile()\n                const dirAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                try {\n                    filetools.makeDir(dirPath);\n                    if (dirAttr) filetools.fs.chmodSync(dirPath, dirAttr);\n                    // in unix timestamp will change if files are later added to folder, but still\n                    filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);\n                } catch (er) {\n                    callback(getError(\"Unable to create folder\", dirPath));\n                }\n            }\n\n            // callback wrapper, for some house keeping\n            const done = () => {\n                if (fileEntries.size === 0) {\n                    callback();\n                }\n            };\n\n            // Extract file entries asynchronously\n            for (const entry of fileEntries.values()) {\n                const entryName = pth.normalize(canonical(entry.entryName.toString()));\n                const filePath = sanitize(targetPath, entryName);\n                entry.getDataAsync(function (content, err_1) {\n                    if (err_1) {\n                        callback(new Error(err_1));\n                        return;\n                    }\n                    if (!content) {\n                        callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));\n                    } else {\n                        // The reverse operation for attr depend on method addFile()\n                        const fileAttr = keepOriginalPermission ? entry.header.fileAttr : undefined;\n                        filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function (succ) {\n                            if (!succ) {\n                                callback(getError(\"Unable to write file\", filePath));\n                                return;\n                            }\n                            filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function (err_2) {\n                                if (err_2) {\n                                    callback(getError(\"Unable to set times\", filePath));\n                                    return;\n                                }\n                                fileEntries.delete(entry);\n                                // call the callback if it was last entry\n                                done();\n                            });\n                        });\n                    }\n                });\n            }\n            // call the callback if fileEntries was empty\n            done();\n        },\n\n        /**\n         * Writes the newly created zip file to disk at the specified location or if a zip was opened and no ``targetFileName`` is provided, it will overwrite the opened zip\n         *\n         * @param targetFileName\n         * @param callback\n         */\n        writeZip: function (/**String*/ targetFileName, /**Function*/ callback) {\n            if (arguments.length === 1) {\n                if (typeof targetFileName === \"function\") {\n                    callback = targetFileName;\n                    targetFileName = \"\";\n                }\n            }\n\n            if (!targetFileName && opts.filename) {\n                targetFileName = opts.filename;\n            }\n            if (!targetFileName) return;\n\n            var zipData = _zip.compressToBuffer();\n            if (zipData) {\n                var ok = filetools.writeFileTo(targetFileName, zipData, true);\n                if (typeof callback === \"function\") callback(!ok ? new Error(\"failed\") : null, \"\");\n            }\n        },\n\n        writeZipPromise: function (/**String*/ targetFileName, /* object */ props) {\n            const { overwrite, perm } = Object.assign({ overwrite: true }, props);\n\n            return new Promise((resolve, reject) => {\n                // find file name\n                if (!targetFileName && opts.filename) targetFileName = opts.filename;\n                if (!targetFileName) reject(\"ADM-ZIP: ZIP File Name Missing\");\n\n                this.toBufferPromise().then((zipData) => {\n                    const ret = (done) => (done ? resolve(done) : reject(\"ADM-ZIP: Wasn't able to write zip file\"));\n                    filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);\n                }, reject);\n            });\n        },\n\n        toBufferPromise: function () {\n            return new Promise((resolve, reject) => {\n                _zip.toAsyncBuffer(resolve, reject);\n            });\n        },\n\n        /**\n         * Returns the content of the entire zip file as a Buffer object\n         *\n         * @return Buffer\n         */\n        toBuffer: function (/**Function=*/ onSuccess, /**Function=*/ onFail, /**Function=*/ onItemStart, /**Function=*/ onItemEnd) {\n            this.valueOf = 2;\n            if (typeof onSuccess === \"function\") {\n                _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);\n                return null;\n            }\n            return _zip.compressToBuffer();\n        }\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}