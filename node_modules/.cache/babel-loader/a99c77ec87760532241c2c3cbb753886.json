{"ast":null,"code":"var Utils = require(\"./util\"),\n    Headers = require(\"./headers\"),\n    Constants = Utils.Constants,\n    Methods = require(\"./methods\");\n\nmodule.exports = function (\n/*Buffer*/\ninput) {\n  var _entryHeader = new Headers.EntryHeader(),\n      _entryName = Buffer.alloc(0),\n      _comment = Buffer.alloc(0),\n      _isDirectory = false,\n      uncompressedData = null,\n      _extra = Buffer.alloc(0);\n\n  function getCompressedDataFromZip() {\n    if (!input || !Buffer.isBuffer(input)) {\n      return Buffer.alloc(0);\n    }\n\n    _entryHeader.loadDataHeaderFromBinary(input);\n\n    return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);\n  }\n\n  function crc32OK(data) {\n    // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n    if ((_entryHeader.flags & 0x8) !== 0x8) {\n      if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {\n        return false;\n      }\n    } else {// @TODO: load and check data descriptor header\n      // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\n      // (optionally preceded by a 4-byte signature) immediately after the compressed data:\n    }\n\n    return true;\n  }\n\n  function decompress(\n  /*Boolean*/\n  async,\n  /*Function*/\n  callback,\n  /*String, Buffer*/\n  pass) {\n    if (typeof callback === \"undefined\" && typeof async === \"string\") {\n      pass = async;\n      async = void 0;\n    }\n\n    if (_isDirectory) {\n      if (async && callback) {\n        callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\n      }\n\n      return Buffer.alloc(0);\n    }\n\n    var compressedData = getCompressedDataFromZip();\n\n    if (compressedData.length === 0) {\n      // File is empty, nothing to decompress.\n      if (async && callback) callback(compressedData);\n      return compressedData;\n    }\n\n    if (_entryHeader.encripted) {\n      if (\"string\" !== typeof pass && !Buffer.isBuffer(pass)) {\n        throw new Error(\"ADM-ZIP: Incompatible password parameter\");\n      }\n\n      compressedData = Methods.ZipCrypto.decrypt(compressedData, _entryHeader, pass);\n    }\n\n    var data = Buffer.alloc(_entryHeader.size);\n\n    switch (_entryHeader.method) {\n      case Utils.Constants.STORED:\n        compressedData.copy(data);\n\n        if (!crc32OK(data)) {\n          if (async && callback) callback(data, Utils.Errors.BAD_CRC); //si added error\n\n          throw new Error(Utils.Errors.BAD_CRC);\n        } else {\n          //si added otherwise did not seem to return data.\n          if (async && callback) callback(data);\n          return data;\n        }\n\n      case Utils.Constants.DEFLATED:\n        var inflater = new Methods.Inflater(compressedData);\n\n        if (!async) {\n          const result = inflater.inflate(data);\n          result.copy(data, 0);\n\n          if (!crc32OK(data)) {\n            throw new Error(Utils.Errors.BAD_CRC + \" \" + _entryName.toString());\n          }\n\n          return data;\n        } else {\n          inflater.inflateAsync(function (result) {\n            result.copy(result, 0);\n\n            if (callback) {\n              if (!crc32OK(result)) {\n                callback(result, Utils.Errors.BAD_CRC); //si added error\n              } else {\n                callback(result);\n              }\n            }\n          });\n        }\n\n        break;\n\n      default:\n        if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);\n        throw new Error(Utils.Errors.UNKNOWN_METHOD);\n    }\n  }\n\n  function compress(\n  /*Boolean*/\n  async,\n  /*Function*/\n  callback) {\n    if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\n      // no data set or the data wasn't changed to require recompression\n      if (async && callback) callback(getCompressedDataFromZip());\n      return getCompressedDataFromZip();\n    }\n\n    if (uncompressedData.length && !_isDirectory) {\n      var compressedData; // Local file header\n\n      switch (_entryHeader.method) {\n        case Utils.Constants.STORED:\n          _entryHeader.compressedSize = _entryHeader.size;\n          compressedData = Buffer.alloc(uncompressedData.length);\n          uncompressedData.copy(compressedData);\n          if (async && callback) callback(compressedData);\n          return compressedData;\n\n        default:\n        case Utils.Constants.DEFLATED:\n          var deflater = new Methods.Deflater(uncompressedData);\n\n          if (!async) {\n            var deflated = deflater.deflate();\n            _entryHeader.compressedSize = deflated.length;\n            return deflated;\n          } else {\n            deflater.deflateAsync(function (data) {\n              compressedData = Buffer.alloc(data.length);\n              _entryHeader.compressedSize = data.length;\n              data.copy(compressedData);\n              callback && callback(compressedData);\n            });\n          }\n\n          deflater = null;\n          break;\n      }\n    } else if (async && callback) {\n      callback(Buffer.alloc(0));\n    } else {\n      return Buffer.alloc(0);\n    }\n  }\n\n  function readUInt64LE(buffer, offset) {\n    return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\n  }\n\n  function parseExtra(data) {\n    var offset = 0;\n    var signature, size, part;\n\n    while (offset < data.length) {\n      signature = data.readUInt16LE(offset);\n      offset += 2;\n      size = data.readUInt16LE(offset);\n      offset += 2;\n      part = data.slice(offset, offset + size);\n      offset += size;\n\n      if (Constants.ID_ZIP64 === signature) {\n        parseZip64ExtendedInformation(part);\n      }\n    }\n  } //Override header field values with values from the ZIP64 extra field\n\n\n  function parseZip64ExtendedInformation(data) {\n    var size, compressedSize, offset, diskNumStart;\n\n    if (data.length >= Constants.EF_ZIP64_SCOMP) {\n      size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\n\n      if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.size = size;\n      }\n    }\n\n    if (data.length >= Constants.EF_ZIP64_RHO) {\n      compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\n\n      if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.compressedSize = compressedSize;\n      }\n    }\n\n    if (data.length >= Constants.EF_ZIP64_DSN) {\n      offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\n\n      if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {\n        _entryHeader.offset = offset;\n      }\n    }\n\n    if (data.length >= Constants.EF_ZIP64_DSN + 4) {\n      diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\n\n      if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\n        _entryHeader.diskNumStart = diskNumStart;\n      }\n    }\n  }\n\n  return {\n    get entryName() {\n      return _entryName.toString();\n    },\n\n    get rawEntryName() {\n      return _entryName;\n    },\n\n    set entryName(val) {\n      _entryName = Utils.toBuffer(val);\n      var lastChar = _entryName[_entryName.length - 1];\n      _isDirectory = lastChar === 47 || lastChar === 92;\n      _entryHeader.fileNameLength = _entryName.length;\n    },\n\n    get extra() {\n      return _extra;\n    },\n\n    set extra(val) {\n      _extra = val;\n      _entryHeader.extraLength = val.length;\n      parseExtra(val);\n    },\n\n    get comment() {\n      return _comment.toString();\n    },\n\n    set comment(val) {\n      _comment = Utils.toBuffer(val);\n      _entryHeader.commentLength = _comment.length;\n    },\n\n    get name() {\n      var n = _entryName.toString();\n\n      return _isDirectory ? n.substr(n.length - 1).split(\"/\").pop() : n.split(\"/\").pop();\n    },\n\n    get isDirectory() {\n      return _isDirectory;\n    },\n\n    getCompressedData: function () {\n      return compress(false, null);\n    },\n    getCompressedDataAsync: function (\n    /*Function*/\n    callback) {\n      compress(true, callback);\n    },\n    setData: function (value) {\n      uncompressedData = Utils.toBuffer(value);\n\n      if (!_isDirectory && uncompressedData.length) {\n        _entryHeader.size = uncompressedData.length;\n        _entryHeader.method = Utils.Constants.DEFLATED;\n        _entryHeader.crc = Utils.crc32(value);\n        _entryHeader.changed = true;\n      } else {\n        // folders and blank files should be stored\n        _entryHeader.method = Utils.Constants.STORED;\n      }\n    },\n    getData: function (pass) {\n      if (_entryHeader.changed) {\n        return uncompressedData;\n      } else {\n        return decompress(false, null, pass);\n      }\n    },\n    getDataAsync: function (\n    /*Function*/\n    callback, pass) {\n      if (_entryHeader.changed) {\n        callback(uncompressedData);\n      } else {\n        decompress(true, callback, pass);\n      }\n    },\n\n    set attr(attr) {\n      _entryHeader.attr = attr;\n    },\n\n    get attr() {\n      return _entryHeader.attr;\n    },\n\n    set header(\n    /*Buffer*/\n    data) {\n      _entryHeader.loadFromBinary(data);\n    },\n\n    get header() {\n      return _entryHeader;\n    },\n\n    packHeader: function () {\n      // 1. create header (buffer)\n      var header = _entryHeader.entryHeaderToBinary();\n\n      var addpos = Utils.Constants.CENHDR; // 2. add file name\n\n      _entryName.copy(header, addpos);\n\n      addpos += _entryName.length; // 3. add extra data\n\n      if (_entryHeader.extraLength) {\n        _extra.copy(header, addpos);\n\n        addpos += _entryHeader.extraLength;\n      } // 4. add file comment\n\n\n      if (_entryHeader.commentLength) {\n        _comment.copy(header, addpos);\n      }\n\n      return header;\n    },\n    toJSON: function () {\n      const bytes = function (nr) {\n        return \"<\" + (nr && nr.length + \" bytes buffer\" || \"null\") + \">\";\n      };\n\n      return {\n        entryName: this.entryName,\n        name: this.name,\n        comment: this.comment,\n        isDirectory: this.isDirectory,\n        header: _entryHeader.toJSON(),\n        compressedData: bytes(input),\n        data: bytes(uncompressedData)\n      };\n    },\n    toString: function () {\n      return JSON.stringify(this.toJSON(), null, \"\\t\");\n    }\n  };\n};","map":{"version":3,"names":["Utils","require","Headers","Constants","Methods","module","exports","input","_entryHeader","EntryHeader","_entryName","Buffer","alloc","_comment","_isDirectory","uncompressedData","_extra","getCompressedDataFromZip","isBuffer","loadDataHeaderFromBinary","slice","realDataOffset","compressedSize","crc32OK","data","flags","crc32","dataHeader","crc","decompress","async","callback","pass","Errors","DIRECTORY_CONTENT_ERROR","compressedData","length","encripted","Error","ZipCrypto","decrypt","size","method","STORED","copy","BAD_CRC","DEFLATED","inflater","Inflater","result","inflate","toString","inflateAsync","UNKNOWN_METHOD","compress","deflater","Deflater","deflated","deflate","deflateAsync","readUInt64LE","buffer","offset","readUInt32LE","parseExtra","signature","part","readUInt16LE","ID_ZIP64","parseZip64ExtendedInformation","diskNumStart","EF_ZIP64_SCOMP","EF_ZIP64_SUNCOMP","EF_ZIP64_OR_32","EF_ZIP64_RHO","EF_ZIP64_DSN","EF_ZIP64_OR_16","entryName","rawEntryName","val","toBuffer","lastChar","fileNameLength","extra","extraLength","comment","commentLength","name","n","substr","split","pop","isDirectory","getCompressedData","getCompressedDataAsync","setData","value","changed","getData","getDataAsync","attr","header","loadFromBinary","packHeader","entryHeaderToBinary","addpos","CENHDR","toJSON","bytes","nr","JSON","stringify"],"sources":["/Users/andrejsmolencev/Desktop/scorm-generator/node_modules/adm-zip/zipEntry.js"],"sourcesContent":["var Utils = require(\"./util\"),\n    Headers = require(\"./headers\"),\n    Constants = Utils.Constants,\n    Methods = require(\"./methods\");\n\nmodule.exports = function (/*Buffer*/ input) {\n    var _entryHeader = new Headers.EntryHeader(),\n        _entryName = Buffer.alloc(0),\n        _comment = Buffer.alloc(0),\n        _isDirectory = false,\n        uncompressedData = null,\n        _extra = Buffer.alloc(0);\n\n    function getCompressedDataFromZip() {\n        if (!input || !Buffer.isBuffer(input)) {\n            return Buffer.alloc(0);\n        }\n        _entryHeader.loadDataHeaderFromBinary(input);\n        return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);\n    }\n\n    function crc32OK(data) {\n        // if bit 3 (0x08) of the general-purpose flags field is set, then the CRC-32 and file sizes are not known when the header is written\n        if ((_entryHeader.flags & 0x8) !== 0x8) {\n            if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {\n                return false;\n            }\n        } else {\n            // @TODO: load and check data descriptor header\n            // The fields in the local header are filled with zero, and the CRC-32 and size are appended in a 12-byte structure\n            // (optionally preceded by a 4-byte signature) immediately after the compressed data:\n        }\n        return true;\n    }\n\n    function decompress(/*Boolean*/ async, /*Function*/ callback, /*String, Buffer*/ pass) {\n        if (typeof callback === \"undefined\" && typeof async === \"string\") {\n            pass = async;\n            async = void 0;\n        }\n        if (_isDirectory) {\n            if (async && callback) {\n                callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR); //si added error.\n            }\n            return Buffer.alloc(0);\n        }\n\n        var compressedData = getCompressedDataFromZip();\n\n        if (compressedData.length === 0) {\n            // File is empty, nothing to decompress.\n            if (async && callback) callback(compressedData);\n            return compressedData;\n        }\n\n        if (_entryHeader.encripted) {\n            if (\"string\" !== typeof pass && !Buffer.isBuffer(pass)) {\n                throw new Error(\"ADM-ZIP: Incompatible password parameter\");\n            }\n            compressedData = Methods.ZipCrypto.decrypt(compressedData, _entryHeader, pass);\n        }\n\n        var data = Buffer.alloc(_entryHeader.size);\n\n        switch (_entryHeader.method) {\n            case Utils.Constants.STORED:\n                compressedData.copy(data);\n                if (!crc32OK(data)) {\n                    if (async && callback) callback(data, Utils.Errors.BAD_CRC); //si added error\n                    throw new Error(Utils.Errors.BAD_CRC);\n                } else {\n                    //si added otherwise did not seem to return data.\n                    if (async && callback) callback(data);\n                    return data;\n                }\n            case Utils.Constants.DEFLATED:\n                var inflater = new Methods.Inflater(compressedData);\n                if (!async) {\n                    const result = inflater.inflate(data);\n                    result.copy(data, 0);\n                    if (!crc32OK(data)) {\n                        throw new Error(Utils.Errors.BAD_CRC + \" \" + _entryName.toString());\n                    }\n                    return data;\n                } else {\n                    inflater.inflateAsync(function (result) {\n                        result.copy(result, 0);\n                        if (callback) {\n                            if (!crc32OK(result)) {\n                                callback(result, Utils.Errors.BAD_CRC); //si added error\n                            } else {\n                                callback(result);\n                            }\n                        }\n                    });\n                }\n                break;\n            default:\n                if (async && callback) callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);\n                throw new Error(Utils.Errors.UNKNOWN_METHOD);\n        }\n    }\n\n    function compress(/*Boolean*/ async, /*Function*/ callback) {\n        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {\n            // no data set or the data wasn't changed to require recompression\n            if (async && callback) callback(getCompressedDataFromZip());\n            return getCompressedDataFromZip();\n        }\n\n        if (uncompressedData.length && !_isDirectory) {\n            var compressedData;\n            // Local file header\n            switch (_entryHeader.method) {\n                case Utils.Constants.STORED:\n                    _entryHeader.compressedSize = _entryHeader.size;\n\n                    compressedData = Buffer.alloc(uncompressedData.length);\n                    uncompressedData.copy(compressedData);\n\n                    if (async && callback) callback(compressedData);\n                    return compressedData;\n                default:\n                case Utils.Constants.DEFLATED:\n                    var deflater = new Methods.Deflater(uncompressedData);\n                    if (!async) {\n                        var deflated = deflater.deflate();\n                        _entryHeader.compressedSize = deflated.length;\n                        return deflated;\n                    } else {\n                        deflater.deflateAsync(function (data) {\n                            compressedData = Buffer.alloc(data.length);\n                            _entryHeader.compressedSize = data.length;\n                            data.copy(compressedData);\n                            callback && callback(compressedData);\n                        });\n                    }\n                    deflater = null;\n                    break;\n            }\n        } else if (async && callback) {\n            callback(Buffer.alloc(0));\n        } else {\n            return Buffer.alloc(0);\n        }\n    }\n\n    function readUInt64LE(buffer, offset) {\n        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);\n    }\n\n    function parseExtra(data) {\n        var offset = 0;\n        var signature, size, part;\n        while (offset < data.length) {\n            signature = data.readUInt16LE(offset);\n            offset += 2;\n            size = data.readUInt16LE(offset);\n            offset += 2;\n            part = data.slice(offset, offset + size);\n            offset += size;\n            if (Constants.ID_ZIP64 === signature) {\n                parseZip64ExtendedInformation(part);\n            }\n        }\n    }\n\n    //Override header field values with values from the ZIP64 extra field\n    function parseZip64ExtendedInformation(data) {\n        var size, compressedSize, offset, diskNumStart;\n\n        if (data.length >= Constants.EF_ZIP64_SCOMP) {\n            size = readUInt64LE(data, Constants.EF_ZIP64_SUNCOMP);\n            if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {\n                _entryHeader.size = size;\n            }\n        }\n        if (data.length >= Constants.EF_ZIP64_RHO) {\n            compressedSize = readUInt64LE(data, Constants.EF_ZIP64_SCOMP);\n            if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {\n                _entryHeader.compressedSize = compressedSize;\n            }\n        }\n        if (data.length >= Constants.EF_ZIP64_DSN) {\n            offset = readUInt64LE(data, Constants.EF_ZIP64_RHO);\n            if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {\n                _entryHeader.offset = offset;\n            }\n        }\n        if (data.length >= Constants.EF_ZIP64_DSN + 4) {\n            diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);\n            if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {\n                _entryHeader.diskNumStart = diskNumStart;\n            }\n        }\n    }\n\n    return {\n        get entryName() {\n            return _entryName.toString();\n        },\n        get rawEntryName() {\n            return _entryName;\n        },\n        set entryName(val) {\n            _entryName = Utils.toBuffer(val);\n            var lastChar = _entryName[_entryName.length - 1];\n            _isDirectory = lastChar === 47 || lastChar === 92;\n            _entryHeader.fileNameLength = _entryName.length;\n        },\n\n        get extra() {\n            return _extra;\n        },\n        set extra(val) {\n            _extra = val;\n            _entryHeader.extraLength = val.length;\n            parseExtra(val);\n        },\n\n        get comment() {\n            return _comment.toString();\n        },\n        set comment(val) {\n            _comment = Utils.toBuffer(val);\n            _entryHeader.commentLength = _comment.length;\n        },\n\n        get name() {\n            var n = _entryName.toString();\n            return _isDirectory\n                ? n\n                      .substr(n.length - 1)\n                      .split(\"/\")\n                      .pop()\n                : n.split(\"/\").pop();\n        },\n        get isDirectory() {\n            return _isDirectory;\n        },\n\n        getCompressedData: function () {\n            return compress(false, null);\n        },\n\n        getCompressedDataAsync: function (/*Function*/ callback) {\n            compress(true, callback);\n        },\n\n        setData: function (value) {\n            uncompressedData = Utils.toBuffer(value);\n            if (!_isDirectory && uncompressedData.length) {\n                _entryHeader.size = uncompressedData.length;\n                _entryHeader.method = Utils.Constants.DEFLATED;\n                _entryHeader.crc = Utils.crc32(value);\n                _entryHeader.changed = true;\n            } else {\n                // folders and blank files should be stored\n                _entryHeader.method = Utils.Constants.STORED;\n            }\n        },\n\n        getData: function (pass) {\n            if (_entryHeader.changed) {\n                return uncompressedData;\n            } else {\n                return decompress(false, null, pass);\n            }\n        },\n\n        getDataAsync: function (/*Function*/ callback, pass) {\n            if (_entryHeader.changed) {\n                callback(uncompressedData);\n            } else {\n                decompress(true, callback, pass);\n            }\n        },\n\n        set attr(attr) {\n            _entryHeader.attr = attr;\n        },\n        get attr() {\n            return _entryHeader.attr;\n        },\n\n        set header(/*Buffer*/ data) {\n            _entryHeader.loadFromBinary(data);\n        },\n\n        get header() {\n            return _entryHeader;\n        },\n\n        packHeader: function () {\n            // 1. create header (buffer)\n            var header = _entryHeader.entryHeaderToBinary();\n            var addpos = Utils.Constants.CENHDR;\n            // 2. add file name\n            _entryName.copy(header, addpos);\n            addpos += _entryName.length;\n            // 3. add extra data\n            if (_entryHeader.extraLength) {\n                _extra.copy(header, addpos);\n                addpos += _entryHeader.extraLength;\n            }\n            // 4. add file comment\n            if (_entryHeader.commentLength) {\n                _comment.copy(header, addpos);\n            }\n            return header;\n        },\n\n        toJSON: function () {\n            const bytes = function (nr) {\n                return \"<\" + ((nr && nr.length + \" bytes buffer\") || \"null\") + \">\";\n            };\n\n            return {\n                entryName: this.entryName,\n                name: this.name,\n                comment: this.comment,\n                isDirectory: this.isDirectory,\n                header: _entryHeader.toJSON(),\n                compressedData: bytes(input),\n                data: bytes(uncompressedData)\n            };\n        },\n\n        toString: function () {\n            return JSON.stringify(this.toJSON(), null, \"\\t\");\n        }\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}