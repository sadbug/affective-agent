{"ast":null,"code":"const ZipEntry = require(\"./zipEntry\");\n\nconst Headers = require(\"./headers\");\n\nconst Utils = require(\"./util\");\n\nmodule.exports = function (\n/*Buffer|null*/\ninBuffer,\n/** object */\noptions) {\n  var entryList = [],\n      entryTable = {},\n      _comment = Buffer.alloc(0),\n      mainHeader = new Headers.MainHeader(),\n      loadedEntries = false; // assign options\n\n\n  const opts = Object.assign(Object.create(null), options);\n  const {\n    noSort\n  } = opts;\n\n  if (inBuffer) {\n    // is a memory buffer\n    readMainHeader(opts.readEntries);\n  } else {\n    // none. is a new file\n    loadedEntries = true;\n  }\n\n  function iterateEntries(callback) {\n    const totalEntries = mainHeader.diskEntries; // total number of entries\n\n    let index = mainHeader.offset; // offset of first CEN header\n\n    for (let i = 0; i < totalEntries; i++) {\n      let tmp = index;\n      const entry = new ZipEntry(inBuffer);\n      entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n      index += entry.header.entryHeaderSize;\n      callback(entry);\n    }\n  }\n\n  function readEntries() {\n    loadedEntries = true;\n    entryTable = {};\n    entryList = new Array(mainHeader.diskEntries); // total number of entries\n\n    var index = mainHeader.offset; // offset of first CEN header\n\n    for (var i = 0; i < entryList.length; i++) {\n      var tmp = index,\n          entry = new ZipEntry(inBuffer);\n      entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);\n      entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);\n\n      if (entry.header.extraLength) {\n        entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);\n      }\n\n      if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\n      index += entry.header.entryHeaderSize;\n      entryList[i] = entry;\n      entryTable[entry.entryName] = entry;\n    }\n  }\n\n  function readMainHeader(\n  /*Boolean*/\n  readNow) {\n    var i = inBuffer.length - Utils.Constants.ENDHDR,\n        // END header size\n    max = Math.max(0, i - 0xffff),\n        // 0xFFFF is the max zip file comment length\n    n = max,\n        endStart = inBuffer.length,\n        endOffset = -1,\n        // Start offset of the END header\n    commentEnd = 0;\n\n    for (i; i >= n; i--) {\n      if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\n\n      if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {\n        // \"PK\\005\\006\"\n        endOffset = i;\n        commentEnd = i;\n        endStart = i + Utils.Constants.ENDHDR; // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\n\n        n = i - Utils.Constants.END64HDR;\n        continue;\n      }\n\n      if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\n        // Found a zip64 signature, let's continue reading the whole zip64 record\n        n = max;\n        continue;\n      }\n\n      if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {\n        // Found the zip64 record, let's determine it's size\n        endOffset = i;\n        endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\n        break;\n      }\n    }\n\n    if (!~endOffset) throw new Error(Utils.Errors.INVALID_FORMAT);\n    mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\n\n    if (mainHeader.commentLength) {\n      _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\n    }\n\n    if (readNow) readEntries();\n  }\n\n  function sortEntries() {\n    if (entryList.length > 1 && !noSort) {\n      entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));\n    }\n  }\n\n  return {\n    /**\n     * Returns an array of ZipEntry objects existent in the current opened archive\n     * @return Array\n     */\n    get entries() {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      return entryList;\n    },\n\n    /**\n     * Archive comment\n     * @return {String}\n     */\n    get comment() {\n      return _comment.toString();\n    },\n\n    set comment(val) {\n      _comment = Utils.toBuffer(val);\n      mainHeader.commentLength = _comment.length;\n    },\n\n    getEntryCount: function () {\n      if (!loadedEntries) {\n        return mainHeader.diskEntries;\n      }\n\n      return entryList.length;\n    },\n    forEach: function (callback) {\n      if (!loadedEntries) {\n        iterateEntries(callback);\n        return;\n      }\n\n      entryList.forEach(callback);\n    },\n\n    /**\n     * Returns a reference to the entry with the given name or null if entry is inexistent\n     *\n     * @param entryName\n     * @return ZipEntry\n     */\n    getEntry: function (\n    /*String*/\n    entryName) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      return entryTable[entryName] || null;\n    },\n\n    /**\n     * Adds the given entry to the entry list\n     *\n     * @param entry\n     */\n    setEntry: function (\n    /*ZipEntry*/\n    entry) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      entryList.push(entry);\n      entryTable[entry.entryName] = entry;\n      mainHeader.totalEntries = entryList.length;\n    },\n\n    /**\n     * Removes the entry with the given name from the entry list.\n     *\n     * If the entry is a directory, then all nested files and directories will be removed\n     * @param entryName\n     */\n    deleteEntry: function (\n    /*String*/\n    entryName) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      var entry = entryTable[entryName];\n\n      if (entry && entry.isDirectory) {\n        var _self = this;\n\n        this.getEntryChildren(entry).forEach(function (child) {\n          if (child.entryName !== entryName) {\n            _self.deleteEntry(child.entryName);\n          }\n        });\n      }\n\n      entryList.splice(entryList.indexOf(entry), 1);\n      delete entryTable[entryName];\n      mainHeader.totalEntries = entryList.length;\n    },\n\n    /**\n     *  Iterates and returns all nested files and directories of the given entry\n     *\n     * @param entry\n     * @return Array\n     */\n    getEntryChildren: function (\n    /*ZipEntry*/\n    entry) {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      if (entry && entry.isDirectory) {\n        const list = [];\n        const name = entry.entryName;\n        const len = name.length;\n        entryList.forEach(function (zipEntry) {\n          if (zipEntry.entryName.substr(0, len) === name) {\n            list.push(zipEntry);\n          }\n        });\n        return list;\n      }\n\n      return [];\n    },\n\n    /**\n     * Returns the zip file\n     *\n     * @return Buffer\n     */\n    compressToBuffer: function () {\n      if (!loadedEntries) {\n        readEntries();\n      }\n\n      sortEntries();\n      const dataBlock = [];\n      const entryHeaders = [];\n      let totalSize = 0;\n      let dindex = 0;\n      mainHeader.size = 0;\n      mainHeader.offset = 0;\n\n      for (const entry of entryList) {\n        // compress data and set local and entry header accordingly. Reason why is called first\n        const compressedData = entry.getCompressedData(); // 1. construct data header\n\n        entry.header.offset = dindex;\n        const dataHeader = entry.header.dataHeaderToBinary();\n        const entryNameLen = entry.rawEntryName.length; // 1.2. postheader - data after data header\n\n        const postHeader = Buffer.alloc(entryNameLen + entry.extra.length);\n        entry.rawEntryName.copy(postHeader, 0);\n        postHeader.copy(entry.extra, entryNameLen); // 2. offsets\n\n        const dataLength = dataHeader.length + postHeader.length + compressedData.length;\n        dindex += dataLength; // 3. store values in sequence\n\n        dataBlock.push(dataHeader);\n        dataBlock.push(postHeader);\n        dataBlock.push(compressedData); // 4. construct entry header\n\n        const entryHeader = entry.packHeader();\n        entryHeaders.push(entryHeader); // 5. update main header\n\n        mainHeader.size += entryHeader.length;\n        totalSize += dataLength + entryHeader.length;\n      }\n\n      totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n      // point to end of data and beginning of central directory first record\n\n      mainHeader.offset = dindex;\n      dindex = 0;\n      const outBuffer = Buffer.alloc(totalSize); // write data blocks\n\n      for (const content of dataBlock) {\n        content.copy(outBuffer, dindex);\n        dindex += content.length;\n      } // write central directory entries\n\n\n      for (const content of entryHeaders) {\n        content.copy(outBuffer, dindex);\n        dindex += content.length;\n      } // write main header\n\n\n      const mh = mainHeader.toBinary();\n\n      if (_comment) {\n        _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n\n      }\n\n      mh.copy(outBuffer, dindex);\n      return outBuffer;\n    },\n    toAsyncBuffer: function (\n    /*Function*/\n    onSuccess,\n    /*Function*/\n    onFail,\n    /*Function*/\n    onItemStart,\n    /*Function*/\n    onItemEnd) {\n      try {\n        if (!loadedEntries) {\n          readEntries();\n        }\n\n        sortEntries();\n        const dataBlock = [];\n        const entryHeaders = [];\n        let totalSize = 0;\n        let dindex = 0;\n        mainHeader.size = 0;\n        mainHeader.offset = 0;\n\n        const compress2Buffer = function (entryLists) {\n          if (entryLists.length) {\n            const entry = entryLists.pop();\n            const name = entry.entryName + entry.extra.toString();\n            if (onItemStart) onItemStart(name);\n            entry.getCompressedDataAsync(function (compressedData) {\n              if (onItemEnd) onItemEnd(name);\n              entry.header.offset = dindex; // data header\n\n              const dataHeader = entry.header.dataHeaderToBinary();\n              const postHeader = Buffer.alloc(name.length, name);\n              const dataLength = dataHeader.length + postHeader.length + compressedData.length;\n              dindex += dataLength;\n              dataBlock.push(dataHeader);\n              dataBlock.push(postHeader);\n              dataBlock.push(compressedData);\n              const entryHeader = entry.packHeader();\n              entryHeaders.push(entryHeader);\n              mainHeader.size += entryHeader.length;\n              totalSize += dataLength + entryHeader.length;\n              compress2Buffer(entryLists);\n            });\n          } else {\n            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n            // point to end of data and beginning of central directory first record\n\n            mainHeader.offset = dindex;\n            dindex = 0;\n            const outBuffer = Buffer.alloc(totalSize);\n            dataBlock.forEach(function (content) {\n              content.copy(outBuffer, dindex); // write data blocks\n\n              dindex += content.length;\n            });\n            entryHeaders.forEach(function (content) {\n              content.copy(outBuffer, dindex); // write central directory entries\n\n              dindex += content.length;\n            });\n            const mh = mainHeader.toBinary();\n\n            if (_comment) {\n              _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n\n            }\n\n            mh.copy(outBuffer, dindex); // write main header\n\n            onSuccess(outBuffer);\n          }\n        };\n\n        compress2Buffer(entryList);\n      } catch (e) {\n        onFail(e);\n      }\n    }\n  };\n};","map":{"version":3,"names":["ZipEntry","require","Headers","Utils","module","exports","inBuffer","options","entryList","entryTable","_comment","Buffer","alloc","mainHeader","MainHeader","loadedEntries","opts","Object","assign","create","noSort","readMainHeader","readEntries","iterateEntries","callback","totalEntries","diskEntries","index","offset","i","tmp","entry","header","slice","Constants","CENHDR","entryName","fileNameLength","entryHeaderSize","Array","length","extraLength","extra","commentLength","comment","readNow","ENDHDR","max","Math","n","endStart","endOffset","commentEnd","readUInt32LE","ENDSIG","END64HDR","END64SIG","ZIP64SIG","readBigUInt64LE","ZIP64SIZE","ZIP64LEAD","Error","Errors","INVALID_FORMAT","loadFromBinary","sortEntries","sort","a","b","toLowerCase","localeCompare","entries","toString","val","toBuffer","getEntryCount","forEach","getEntry","setEntry","push","deleteEntry","isDirectory","_self","getEntryChildren","child","splice","indexOf","list","name","len","zipEntry","substr","compressToBuffer","dataBlock","entryHeaders","totalSize","dindex","size","compressedData","getCompressedData","dataHeader","dataHeaderToBinary","entryNameLen","rawEntryName","postHeader","copy","dataLength","entryHeader","packHeader","mainHeaderSize","outBuffer","content","mh","toBinary","toAsyncBuffer","onSuccess","onFail","onItemStart","onItemEnd","compress2Buffer","entryLists","pop","getCompressedDataAsync","e"],"sources":["/Users/andrejsmolencev/Desktop/scorm-generator/node_modules/adm-zip/zipFile.js"],"sourcesContent":["const ZipEntry = require(\"./zipEntry\");\nconst Headers = require(\"./headers\");\nconst Utils = require(\"./util\");\n\nmodule.exports = function (/*Buffer|null*/ inBuffer, /** object */ options) {\n    var entryList = [],\n        entryTable = {},\n        _comment = Buffer.alloc(0),\n        mainHeader = new Headers.MainHeader(),\n        loadedEntries = false;\n\n    // assign options\n    const opts = Object.assign(Object.create(null), options);\n\n    const { noSort } = opts;\n\n    if (inBuffer) {\n        // is a memory buffer\n        readMainHeader(opts.readEntries);\n    } else {\n        // none. is a new file\n        loadedEntries = true;\n    }\n\n    function iterateEntries(callback) {\n        const totalEntries = mainHeader.diskEntries; // total number of entries\n        let index = mainHeader.offset; // offset of first CEN header\n\n        for (let i = 0; i < totalEntries; i++) {\n            let tmp = index;\n            const entry = new ZipEntry(inBuffer);\n\n            entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));\n            entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));\n\n            index += entry.header.entryHeaderSize;\n\n            callback(entry);\n        }\n    }\n\n    function readEntries() {\n        loadedEntries = true;\n        entryTable = {};\n        entryList = new Array(mainHeader.diskEntries); // total number of entries\n        var index = mainHeader.offset; // offset of first CEN header\n        for (var i = 0; i < entryList.length; i++) {\n            var tmp = index,\n                entry = new ZipEntry(inBuffer);\n            entry.header = inBuffer.slice(tmp, (tmp += Utils.Constants.CENHDR));\n\n            entry.entryName = inBuffer.slice(tmp, (tmp += entry.header.fileNameLength));\n\n            if (entry.header.extraLength) {\n                entry.extra = inBuffer.slice(tmp, (tmp += entry.header.extraLength));\n            }\n\n            if (entry.header.commentLength) entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);\n\n            index += entry.header.entryHeaderSize;\n\n            entryList[i] = entry;\n            entryTable[entry.entryName] = entry;\n        }\n    }\n\n    function readMainHeader(/*Boolean*/ readNow) {\n        var i = inBuffer.length - Utils.Constants.ENDHDR, // END header size\n            max = Math.max(0, i - 0xffff), // 0xFFFF is the max zip file comment length\n            n = max,\n            endStart = inBuffer.length,\n            endOffset = -1, // Start offset of the END header\n            commentEnd = 0;\n\n        for (i; i >= n; i--) {\n            if (inBuffer[i] !== 0x50) continue; // quick check that the byte is 'P'\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {\n                // \"PK\\005\\006\"\n                endOffset = i;\n                commentEnd = i;\n                endStart = i + Utils.Constants.ENDHDR;\n                // We already found a regular signature, let's look just a bit further to check if there's any zip64 signature\n                n = i - Utils.Constants.END64HDR;\n                continue;\n            }\n\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {\n                // Found a zip64 signature, let's continue reading the whole zip64 record\n                n = max;\n                continue;\n            }\n\n            if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {\n                // Found the zip64 record, let's determine it's size\n                endOffset = i;\n                endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;\n                break;\n            }\n        }\n\n        if (!~endOffset) throw new Error(Utils.Errors.INVALID_FORMAT);\n\n        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));\n        if (mainHeader.commentLength) {\n            _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);\n        }\n        if (readNow) readEntries();\n    }\n\n    function sortEntries() {\n        if (entryList.length > 1 && !noSort) {\n            entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));\n        }\n    }\n\n    return {\n        /**\n         * Returns an array of ZipEntry objects existent in the current opened archive\n         * @return Array\n         */\n        get entries() {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            return entryList;\n        },\n\n        /**\n         * Archive comment\n         * @return {String}\n         */\n        get comment() {\n            return _comment.toString();\n        },\n        set comment(val) {\n            _comment = Utils.toBuffer(val);\n            mainHeader.commentLength = _comment.length;\n        },\n\n        getEntryCount: function () {\n            if (!loadedEntries) {\n                return mainHeader.diskEntries;\n            }\n\n            return entryList.length;\n        },\n\n        forEach: function (callback) {\n            if (!loadedEntries) {\n                iterateEntries(callback);\n                return;\n            }\n\n            entryList.forEach(callback);\n        },\n\n        /**\n         * Returns a reference to the entry with the given name or null if entry is inexistent\n         *\n         * @param entryName\n         * @return ZipEntry\n         */\n        getEntry: function (/*String*/ entryName) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            return entryTable[entryName] || null;\n        },\n\n        /**\n         * Adds the given entry to the entry list\n         *\n         * @param entry\n         */\n        setEntry: function (/*ZipEntry*/ entry) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            entryList.push(entry);\n            entryTable[entry.entryName] = entry;\n            mainHeader.totalEntries = entryList.length;\n        },\n\n        /**\n         * Removes the entry with the given name from the entry list.\n         *\n         * If the entry is a directory, then all nested files and directories will be removed\n         * @param entryName\n         */\n        deleteEntry: function (/*String*/ entryName) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            var entry = entryTable[entryName];\n            if (entry && entry.isDirectory) {\n                var _self = this;\n                this.getEntryChildren(entry).forEach(function (child) {\n                    if (child.entryName !== entryName) {\n                        _self.deleteEntry(child.entryName);\n                    }\n                });\n            }\n            entryList.splice(entryList.indexOf(entry), 1);\n            delete entryTable[entryName];\n            mainHeader.totalEntries = entryList.length;\n        },\n\n        /**\n         *  Iterates and returns all nested files and directories of the given entry\n         *\n         * @param entry\n         * @return Array\n         */\n        getEntryChildren: function (/*ZipEntry*/ entry) {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            if (entry && entry.isDirectory) {\n                const list = [];\n                const name = entry.entryName;\n                const len = name.length;\n\n                entryList.forEach(function (zipEntry) {\n                    if (zipEntry.entryName.substr(0, len) === name) {\n                        list.push(zipEntry);\n                    }\n                });\n                return list;\n            }\n            return [];\n        },\n\n        /**\n         * Returns the zip file\n         *\n         * @return Buffer\n         */\n        compressToBuffer: function () {\n            if (!loadedEntries) {\n                readEntries();\n            }\n            sortEntries();\n\n            const dataBlock = [];\n            const entryHeaders = [];\n            let totalSize = 0;\n            let dindex = 0;\n\n            mainHeader.size = 0;\n            mainHeader.offset = 0;\n\n            for (const entry of entryList) {\n                // compress data and set local and entry header accordingly. Reason why is called first\n                const compressedData = entry.getCompressedData();\n                // 1. construct data header\n                entry.header.offset = dindex;\n                const dataHeader = entry.header.dataHeaderToBinary();\n                const entryNameLen = entry.rawEntryName.length;\n                // 1.2. postheader - data after data header\n                const postHeader = Buffer.alloc(entryNameLen + entry.extra.length);\n                entry.rawEntryName.copy(postHeader, 0);\n                postHeader.copy(entry.extra, entryNameLen);\n\n                // 2. offsets\n                const dataLength = dataHeader.length + postHeader.length + compressedData.length;\n                dindex += dataLength;\n\n                // 3. store values in sequence\n                dataBlock.push(dataHeader);\n                dataBlock.push(postHeader);\n                dataBlock.push(compressedData);\n\n                // 4. construct entry header\n                const entryHeader = entry.packHeader();\n                entryHeaders.push(entryHeader);\n                // 5. update main header\n                mainHeader.size += entryHeader.length;\n                totalSize += dataLength + entryHeader.length;\n            }\n\n            totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n            // point to end of data and beginning of central directory first record\n            mainHeader.offset = dindex;\n\n            dindex = 0;\n            const outBuffer = Buffer.alloc(totalSize);\n            // write data blocks\n            for (const content of dataBlock) {\n                content.copy(outBuffer, dindex);\n                dindex += content.length;\n            }\n\n            // write central directory entries\n            for (const content of entryHeaders) {\n                content.copy(outBuffer, dindex);\n                dindex += content.length;\n            }\n\n            // write main header\n            const mh = mainHeader.toBinary();\n            if (_comment) {\n                _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n            }\n            mh.copy(outBuffer, dindex);\n\n            return outBuffer;\n        },\n\n        toAsyncBuffer: function (/*Function*/ onSuccess, /*Function*/ onFail, /*Function*/ onItemStart, /*Function*/ onItemEnd) {\n            try {\n                if (!loadedEntries) {\n                    readEntries();\n                }\n                sortEntries();\n\n                const dataBlock = [];\n                const entryHeaders = [];\n                let totalSize = 0;\n                let dindex = 0;\n\n                mainHeader.size = 0;\n                mainHeader.offset = 0;\n\n                const compress2Buffer = function (entryLists) {\n                    if (entryLists.length) {\n                        const entry = entryLists.pop();\n                        const name = entry.entryName + entry.extra.toString();\n                        if (onItemStart) onItemStart(name);\n                        entry.getCompressedDataAsync(function (compressedData) {\n                            if (onItemEnd) onItemEnd(name);\n\n                            entry.header.offset = dindex;\n                            // data header\n                            const dataHeader = entry.header.dataHeaderToBinary();\n                            const postHeader = Buffer.alloc(name.length, name);\n                            const dataLength = dataHeader.length + postHeader.length + compressedData.length;\n\n                            dindex += dataLength;\n\n                            dataBlock.push(dataHeader);\n                            dataBlock.push(postHeader);\n                            dataBlock.push(compressedData);\n\n                            const entryHeader = entry.packHeader();\n                            entryHeaders.push(entryHeader);\n                            mainHeader.size += entryHeader.length;\n                            totalSize += dataLength + entryHeader.length;\n\n                            compress2Buffer(entryLists);\n                        });\n                    } else {\n                        totalSize += mainHeader.mainHeaderSize; // also includes zip file comment length\n                        // point to end of data and beginning of central directory first record\n                        mainHeader.offset = dindex;\n\n                        dindex = 0;\n                        const outBuffer = Buffer.alloc(totalSize);\n                        dataBlock.forEach(function (content) {\n                            content.copy(outBuffer, dindex); // write data blocks\n                            dindex += content.length;\n                        });\n                        entryHeaders.forEach(function (content) {\n                            content.copy(outBuffer, dindex); // write central directory entries\n                            dindex += content.length;\n                        });\n\n                        const mh = mainHeader.toBinary();\n                        if (_comment) {\n                            _comment.copy(mh, Utils.Constants.ENDHDR); // add zip file comment\n                        }\n\n                        mh.copy(outBuffer, dindex); // write main header\n\n                        onSuccess(outBuffer);\n                    }\n                };\n\n                compress2Buffer(entryList);\n            } catch (e) {\n                onFail(e);\n            }\n        }\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}