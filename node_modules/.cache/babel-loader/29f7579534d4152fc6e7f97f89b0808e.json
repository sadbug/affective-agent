{"ast":null,"code":"\"use strict\"; // node crypt, we use it for generate salt\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\nconst {\n  randomFillSync\n} = require(\"crypto\"); // generate CRC32 lookup table\n\n\nconst crctable = new Uint32Array(256).map((t, crc) => {\n  for (let j = 0; j < 8; j++) {\n    if (0 !== (crc & 1)) {\n      crc = crc >>> 1 ^ 0xedb88320;\n    } else {\n      crc >>>= 1;\n    }\n  }\n\n  return crc >>> 0;\n}); // C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)\n\nconst uMul = (a, b) => Math.imul(a, b) >>> 0; // crc32 byte single update (actually same function is part of utils.crc32 function :) )\n\n\nconst crc32update = (pCrc32, bval) => {\n  return crctable[(pCrc32 ^ bval) & 0xff] ^ pCrc32 >>> 8;\n}; // function for generating salt for encrytion header\n\n\nconst genSalt = () => {\n  if (\"function\" === typeof randomFillSync) {\n    return randomFillSync(Buffer.alloc(12));\n  } else {\n    // fallback if function is not defined\n    return genSalt.node();\n  }\n}; // salt generation with node random function (mainly as fallback)\n\n\ngenSalt.node = () => {\n  const salt = Buffer.alloc(12);\n  const len = salt.length;\n\n  for (let i = 0; i < len; i++) salt[i] = Math.random() * 256 & 0xff;\n\n  return salt;\n}; // general config\n\n\nconst config = {\n  genSalt\n}; // Class Initkeys handles same basic ops with keys\n\nfunction Initkeys(pw) {\n  const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);\n  this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);\n\n  for (let i = 0; i < pass.length; i++) {\n    this.updateKeys(pass[i]);\n  }\n}\n\nInitkeys.prototype.updateKeys = function (byteValue) {\n  const keys = this.keys;\n  keys[0] = crc32update(keys[0], byteValue);\n  keys[1] += keys[0] & 0xff;\n  keys[1] = uMul(keys[1], 134775813) + 1;\n  keys[2] = crc32update(keys[2], keys[1] >>> 24);\n  return byteValue;\n};\n\nInitkeys.prototype.next = function () {\n  const k = (this.keys[2] | 2) >>> 0; // key\n\n  return uMul(k, k ^ 1) >> 8 & 0xff; // decode\n};\n\nfunction make_decrypter(\n/*Buffer*/\npwd) {\n  // 1. Stage initialize key\n  const keys = new Initkeys(pwd); // return decrypter function\n\n  return function (\n  /*Buffer*/\n  data) {\n    // result - we create new Buffer for results\n    const result = Buffer.alloc(data.length);\n    let pos = 0; // process input data\n\n    for (let c of data) {\n      //c ^= keys.next();\n      //result[pos++] = c; // decode & Save Value\n      result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte\n    }\n\n    return result;\n  };\n}\n\nfunction make_encrypter(\n/*Buffer*/\npwd) {\n  // 1. Stage initialize key\n  const keys = new Initkeys(pwd); // return encrypting function, result and pos is here so we dont have to merge buffers later\n\n  return function (\n  /*Buffer*/\n  data,\n  /*Buffer*/\n  result) {\n    let pos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    // result - we create new Buffer for results\n    if (!result) result = Buffer.alloc(data.length); // process input data\n\n    for (let c of data) {\n      const k = keys.next(); // save key byte\n\n      result[pos++] = c ^ k; // save val\n\n      keys.updateKeys(c); // update keys with decoded byte\n    }\n\n    return result;\n  };\n}\n\nfunction decrypt(\n/*Buffer*/\ndata,\n/*Object*/\nheader,\n/*String, Buffer*/\npwd) {\n  if (!data || !Buffer.isBuffer(data) || data.length < 12) {\n    return Buffer.alloc(0);\n  } // 1. We Initialize and generate decrypting function\n\n\n  const decrypter = make_decrypter(pwd); // 2. decrypt salt what is always 12 bytes and is a part of file content\n\n  const salt = decrypter(data.slice(0, 12)); // 3. does password meet expectations\n\n  if (salt[11] !== header.crc >>> 24) {\n    throw \"ADM-ZIP: Wrong Password\";\n  } // 4. decode content\n\n\n  return decrypter(data.slice(12));\n} // lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality\n\n\nfunction _salter(data) {\n  if (Buffer.isBuffer(data) && data.length >= 12) {\n    // be aware - currently salting buffer data is modified\n    config.genSalt = function () {\n      return data.slice(0, 12);\n    };\n  } else if (data === \"node\") {\n    // test salt generation with node random function\n    config.genSalt = genSalt.node;\n  } else {\n    // if value is not acceptable config gets reset.\n    config.genSalt = genSalt;\n  }\n}\n\nfunction encrypt(\n/*Buffer*/\ndata,\n/*Object*/\nheader,\n/*String, Buffer*/\npwd) {\n  let oldlike = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // 1. test data if data is not Buffer we make buffer from it\n  if (data == null) data = Buffer.alloc(0); // if data is not buffer be make buffer from it\n\n  if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString()); // 2. We Initialize and generate encrypting function\n\n  const encrypter = make_encrypter(pwd); // 3. generate salt (12-bytes of random data)\n\n  const salt = config.genSalt();\n  salt[11] = header.crc >>> 24 & 0xff; // old implementations (before PKZip 2.04g) used two byte check\n\n  if (oldlike) salt[10] = header.crc >>> 16 & 0xff; // 4. create output\n\n  const result = Buffer.alloc(data.length + 12);\n  encrypter(salt, result); // finally encode content\n\n  return encrypter(data, result, 12);\n}\n\nmodule.exports = {\n  decrypt,\n  encrypt,\n  _salter\n};","map":{"version":3,"names":["randomFillSync","require","crctable","Uint32Array","map","t","crc","j","uMul","a","b","Math","imul","crc32update","pCrc32","bval","genSalt","Buffer","alloc","node","salt","len","length","i","random","config","Initkeys","pw","pass","isBuffer","from","keys","updateKeys","prototype","byteValue","next","k","make_decrypter","pwd","data","result","pos","c","make_encrypter","decrypt","header","decrypter","slice","_salter","encrypt","oldlike","toString","encrypter","module","exports"],"sources":["/Users/andrejsmolencev/Desktop/scorm-generator/node_modules/adm-zip/methods/zipcrypto.js"],"sourcesContent":["\"use strict\";\n\n// node crypt, we use it for generate salt\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst { randomFillSync } = require(\"crypto\");\n\n// generate CRC32 lookup table\nconst crctable = new Uint32Array(256).map((t, crc) => {\n    for (let j = 0; j < 8; j++) {\n        if (0 !== (crc & 1)) {\n            crc = (crc >>> 1) ^ 0xedb88320;\n        } else {\n            crc >>>= 1;\n        }\n    }\n    return crc >>> 0;\n});\n\n// C-style uInt32 Multiply (discards higher bits, when JS multiply discards lower bits)\nconst uMul = (a, b) => Math.imul(a, b) >>> 0;\n\n// crc32 byte single update (actually same function is part of utils.crc32 function :) )\nconst crc32update = (pCrc32, bval) => {\n    return crctable[(pCrc32 ^ bval) & 0xff] ^ (pCrc32 >>> 8);\n};\n\n// function for generating salt for encrytion header\nconst genSalt = () => {\n    if (\"function\" === typeof randomFillSync) {\n        return randomFillSync(Buffer.alloc(12));\n    } else {\n        // fallback if function is not defined\n        return genSalt.node();\n    }\n};\n\n// salt generation with node random function (mainly as fallback)\ngenSalt.node = () => {\n    const salt = Buffer.alloc(12);\n    const len = salt.length;\n    for (let i = 0; i < len; i++) salt[i] = (Math.random() * 256) & 0xff;\n    return salt;\n};\n\n// general config\nconst config = {\n    genSalt\n};\n\n// Class Initkeys handles same basic ops with keys\nfunction Initkeys(pw) {\n    const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);\n    this.keys = new Uint32Array([0x12345678, 0x23456789, 0x34567890]);\n    for (let i = 0; i < pass.length; i++) {\n        this.updateKeys(pass[i]);\n    }\n}\n\nInitkeys.prototype.updateKeys = function (byteValue) {\n    const keys = this.keys;\n    keys[0] = crc32update(keys[0], byteValue);\n    keys[1] += keys[0] & 0xff;\n    keys[1] = uMul(keys[1], 134775813) + 1;\n    keys[2] = crc32update(keys[2], keys[1] >>> 24);\n    return byteValue;\n};\n\nInitkeys.prototype.next = function () {\n    const k = (this.keys[2] | 2) >>> 0; // key\n    return (uMul(k, k ^ 1) >> 8) & 0xff; // decode\n};\n\nfunction make_decrypter(/*Buffer*/ pwd) {\n    // 1. Stage initialize key\n    const keys = new Initkeys(pwd);\n\n    // return decrypter function\n    return function (/*Buffer*/ data) {\n        // result - we create new Buffer for results\n        const result = Buffer.alloc(data.length);\n        let pos = 0;\n        // process input data\n        for (let c of data) {\n            //c ^= keys.next();\n            //result[pos++] = c; // decode & Save Value\n            result[pos++] = keys.updateKeys(c ^ keys.next()); // update keys with decoded byte\n        }\n        return result;\n    };\n}\n\nfunction make_encrypter(/*Buffer*/ pwd) {\n    // 1. Stage initialize key\n    const keys = new Initkeys(pwd);\n\n    // return encrypting function, result and pos is here so we dont have to merge buffers later\n    return function (/*Buffer*/ data, /*Buffer*/ result, /* Number */ pos = 0) {\n        // result - we create new Buffer for results\n        if (!result) result = Buffer.alloc(data.length);\n        // process input data\n        for (let c of data) {\n            const k = keys.next(); // save key byte\n            result[pos++] = c ^ k; // save val\n            keys.updateKeys(c); // update keys with decoded byte\n        }\n        return result;\n    };\n}\n\nfunction decrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd) {\n    if (!data || !Buffer.isBuffer(data) || data.length < 12) {\n        return Buffer.alloc(0);\n    }\n\n    // 1. We Initialize and generate decrypting function\n    const decrypter = make_decrypter(pwd);\n\n    // 2. decrypt salt what is always 12 bytes and is a part of file content\n    const salt = decrypter(data.slice(0, 12));\n\n    // 3. does password meet expectations\n    if (salt[11] !== header.crc >>> 24) {\n        throw \"ADM-ZIP: Wrong Password\";\n    }\n\n    // 4. decode content\n    return decrypter(data.slice(12));\n}\n\n// lets add way to populate salt, NOT RECOMMENDED for production but maybe useful for testing general functionality\nfunction _salter(data) {\n    if (Buffer.isBuffer(data) && data.length >= 12) {\n        // be aware - currently salting buffer data is modified\n        config.genSalt = function () {\n            return data.slice(0, 12);\n        };\n    } else if (data === \"node\") {\n        // test salt generation with node random function\n        config.genSalt = genSalt.node;\n    } else {\n        // if value is not acceptable config gets reset.\n        config.genSalt = genSalt;\n    }\n}\n\nfunction encrypt(/*Buffer*/ data, /*Object*/ header, /*String, Buffer*/ pwd, /*Boolean*/ oldlike = false) {\n    // 1. test data if data is not Buffer we make buffer from it\n    if (data == null) data = Buffer.alloc(0);\n    // if data is not buffer be make buffer from it\n    if (!Buffer.isBuffer(data)) data = Buffer.from(data.toString());\n\n    // 2. We Initialize and generate encrypting function\n    const encrypter = make_encrypter(pwd);\n\n    // 3. generate salt (12-bytes of random data)\n    const salt = config.genSalt();\n    salt[11] = (header.crc >>> 24) & 0xff;\n\n    // old implementations (before PKZip 2.04g) used two byte check\n    if (oldlike) salt[10] = (header.crc >>> 16) & 0xff;\n\n    // 4. create output\n    const result = Buffer.alloc(data.length + 12);\n    encrypter(salt, result);\n\n    // finally encode content\n    return encrypter(data, result, 12);\n}\n\nmodule.exports = { decrypt, encrypt, _salter };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}