{"ast":null,"code":"const fsystem = require(\"./fileSystem\").require();\n\nconst pth = require(\"path\");\n\nconst Constants = require(\"./constants\");\n\nconst isWin = typeof process === \"object\" && \"win32\" === process.platform;\n\nconst is_Obj = obj => obj && typeof obj === \"object\"; // generate CRC32 lookup table\n\n\nconst crcTable = new Uint32Array(256).map((t, c) => {\n  for (let k = 0; k < 8; k++) {\n    if ((c & 1) !== 0) {\n      c = 0xedb88320 ^ c >>> 1;\n    } else {\n      c >>>= 1;\n    }\n  }\n\n  return c >>> 0;\n}); // UTILS functions\n\nfunction Utils(opts) {\n  this.sep = pth.sep;\n  this.fs = fsystem;\n\n  if (is_Obj(opts)) {\n    // custom filesystem\n    if (is_Obj(opts.fs) && typeof opts.fs.statSync === \"function\") {\n      this.fs = opts.fs;\n    }\n  }\n}\n\nmodule.exports = Utils; // INSTANCED functions\n\nUtils.prototype.makeDir = function (\n/*String*/\nfolder) {\n  const self = this; // Sync - make directories tree\n\n  function mkdirSync(\n  /*String*/\n  fpath) {\n    let resolvedPath = fpath.split(self.sep)[0];\n    fpath.split(self.sep).forEach(function (name) {\n      if (!name || name.substr(-1, 1) === \":\") return;\n      resolvedPath += self.sep + name;\n      var stat;\n\n      try {\n        stat = self.fs.statSync(resolvedPath);\n      } catch (e) {\n        self.fs.mkdirSync(resolvedPath);\n      }\n\n      if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY.replace(\"%s\", resolvedPath);\n    });\n  }\n\n  mkdirSync(folder);\n};\n\nUtils.prototype.writeFileTo = function (\n/*String*/\npath,\n/*Buffer*/\ncontent,\n/*Boolean*/\noverwrite,\n/*Number*/\nattr) {\n  const self = this;\n\n  if (self.fs.existsSync(path)) {\n    if (!overwrite) return false; // cannot overwrite\n\n    var stat = self.fs.statSync(path);\n\n    if (stat.isDirectory()) {\n      return false;\n    }\n  }\n\n  var folder = pth.dirname(path);\n\n  if (!self.fs.existsSync(folder)) {\n    self.makeDir(folder);\n  }\n\n  var fd;\n\n  try {\n    fd = self.fs.openSync(path, \"w\", 438); // 0666\n  } catch (e) {\n    self.fs.chmodSync(path, 438);\n    fd = self.fs.openSync(path, \"w\", 438);\n  }\n\n  if (fd) {\n    try {\n      self.fs.writeSync(fd, content, 0, content.length, 0);\n    } finally {\n      self.fs.closeSync(fd);\n    }\n  }\n\n  self.fs.chmodSync(path, attr || 438);\n  return true;\n};\n\nUtils.prototype.writeFileToAsync = function (\n/*String*/\npath,\n/*Buffer*/\ncontent,\n/*Boolean*/\noverwrite,\n/*Number*/\nattr,\n/*Function*/\ncallback) {\n  if (typeof attr === \"function\") {\n    callback = attr;\n    attr = undefined;\n  }\n\n  const self = this;\n  self.fs.exists(path, function (exist) {\n    if (exist && !overwrite) return callback(false);\n    self.fs.stat(path, function (err, stat) {\n      if (exist && stat.isDirectory()) {\n        return callback(false);\n      }\n\n      var folder = pth.dirname(path);\n      self.fs.exists(folder, function (exists) {\n        if (!exists) self.makeDir(folder);\n        self.fs.open(path, \"w\", 438, function (err, fd) {\n          if (err) {\n            self.fs.chmod(path, 438, function () {\n              self.fs.open(path, \"w\", 438, function (err, fd) {\n                self.fs.write(fd, content, 0, content.length, 0, function () {\n                  self.fs.close(fd, function () {\n                    self.fs.chmod(path, attr || 438, function () {\n                      callback(true);\n                    });\n                  });\n                });\n              });\n            });\n          } else if (fd) {\n            self.fs.write(fd, content, 0, content.length, 0, function () {\n              self.fs.close(fd, function () {\n                self.fs.chmod(path, attr || 438, function () {\n                  callback(true);\n                });\n              });\n            });\n          } else {\n            self.fs.chmod(path, attr || 438, function () {\n              callback(true);\n            });\n          }\n        });\n      });\n    });\n  });\n};\n\nUtils.prototype.findFiles = function (\n/*String*/\npath) {\n  const self = this;\n\n  function findSync(\n  /*String*/\n  dir,\n  /*RegExp*/\n  pattern,\n  /*Boolean*/\n  recursive) {\n    if (typeof pattern === \"boolean\") {\n      recursive = pattern;\n      pattern = undefined;\n    }\n\n    let files = [];\n    self.fs.readdirSync(dir).forEach(function (file) {\n      var path = pth.join(dir, file);\n      if (self.fs.statSync(path).isDirectory() && recursive) files = files.concat(findSync(path, pattern, recursive));\n\n      if (!pattern || pattern.test(path)) {\n        files.push(pth.normalize(path) + (self.fs.statSync(path).isDirectory() ? self.sep : \"\"));\n      }\n    });\n    return files;\n  }\n\n  return findSync(path, undefined, true);\n};\n\nUtils.prototype.getAttributes = function () {};\n\nUtils.prototype.setAttributes = function () {}; // STATIC functions\n// crc32 single update (it is part of crc32)\n\n\nUtils.crc32update = function (crc, byte) {\n  return crcTable[(crc ^ byte) & 0xff] ^ crc >>> 8;\n};\n\nUtils.crc32 = function (buf) {\n  if (typeof buf === \"string\") {\n    buf = Buffer.from(buf, \"utf8\");\n  } // Generate crcTable\n\n\n  if (!crcTable.length) genCRCTable();\n  let len = buf.length;\n  let crc = ~0;\n\n  for (let off = 0; off < len;) crc = Utils.crc32update(crc, buf[off++]); // xor and cast as uint32 number\n\n\n  return ~crc >>> 0;\n};\n\nUtils.methodToString = function (\n/*Number*/\nmethod) {\n  switch (method) {\n    case Constants.STORED:\n      return \"STORED (\" + method + \")\";\n\n    case Constants.DEFLATED:\n      return \"DEFLATED (\" + method + \")\";\n\n    default:\n      return \"UNSUPPORTED (\" + method + \")\";\n  }\n}; // removes \"..\" style path elements\n\n\nUtils.canonical = function (\n/*string*/\npath) {\n  if (!path) return \"\"; // trick normalize think path is absolute\n\n  var safeSuffix = pth.posix.normalize(\"/\" + path.split(\"\\\\\").join(\"/\"));\n  return pth.join(\".\", safeSuffix);\n}; // make abolute paths taking prefix as root folder\n\n\nUtils.sanitize = function (\n/*string*/\nprefix,\n/*string*/\nname) {\n  prefix = pth.resolve(pth.normalize(prefix));\n  var parts = name.split(\"/\");\n\n  for (var i = 0, l = parts.length; i < l; i++) {\n    var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\n\n    if (path.indexOf(prefix) === 0) {\n      return path;\n    }\n  }\n\n  return pth.normalize(pth.join(prefix, pth.basename(name)));\n}; // converts buffer, Uint8Array, string types to buffer\n\n\nUtils.toBuffer = function toBuffer(\n/*buffer, Uint8Array, string*/\ninput) {\n  if (Buffer.isBuffer(input)) {\n    return input;\n  } else if (input instanceof Uint8Array) {\n    return Buffer.from(input);\n  } else {\n    // expect string all other values are invalid and return empty buffer\n    return typeof input === \"string\" ? Buffer.from(input, \"utf8\") : Buffer.alloc(0);\n  }\n};\n\nUtils.readBigUInt64LE = function (\n/*Buffer*/\nbuffer,\n/*int*/\nindex) {\n  var slice = Buffer.from(buffer.slice(index, index + 8));\n  slice.swap64();\n  return parseInt(`0x${slice.toString(\"hex\")}`);\n};\n\nUtils.isWin = isWin; // Do we have windows system\n\nUtils.crcTable = crcTable;","map":{"version":3,"names":["fsystem","require","pth","Constants","isWin","process","platform","is_Obj","obj","crcTable","Uint32Array","map","t","c","k","Utils","opts","sep","fs","statSync","module","exports","prototype","makeDir","folder","self","mkdirSync","fpath","resolvedPath","split","forEach","name","substr","stat","e","isFile","Errors","FILE_IN_THE_WAY","replace","writeFileTo","path","content","overwrite","attr","existsSync","isDirectory","dirname","fd","openSync","chmodSync","writeSync","length","closeSync","writeFileToAsync","callback","undefined","exists","exist","err","open","chmod","write","close","findFiles","findSync","dir","pattern","recursive","files","readdirSync","file","join","concat","test","push","normalize","getAttributes","setAttributes","crc32update","crc","byte","crc32","buf","Buffer","from","genCRCTable","len","off","methodToString","method","STORED","DEFLATED","canonical","safeSuffix","posix","sanitize","prefix","resolve","parts","i","l","slice","indexOf","basename","toBuffer","input","isBuffer","Uint8Array","alloc","readBigUInt64LE","buffer","index","swap64","parseInt","toString"],"sources":["/Users/andrejsmolencev/Desktop/scorm-generator/node_modules/adm-zip/util/utils.js"],"sourcesContent":["const fsystem = require(\"./fileSystem\").require();\nconst pth = require(\"path\");\nconst Constants = require(\"./constants\");\nconst isWin = typeof process === \"object\" && \"win32\" === process.platform;\n\nconst is_Obj = (obj) => obj && typeof obj === \"object\";\n\n// generate CRC32 lookup table\nconst crcTable = new Uint32Array(256).map((t, c) => {\n    for (let k = 0; k < 8; k++) {\n        if ((c & 1) !== 0) {\n            c = 0xedb88320 ^ (c >>> 1);\n        } else {\n            c >>>= 1;\n        }\n    }\n    return c >>> 0;\n});\n\n// UTILS functions\n\nfunction Utils(opts) {\n    this.sep = pth.sep;\n    this.fs = fsystem;\n\n    if (is_Obj(opts)) {\n        // custom filesystem\n        if (is_Obj(opts.fs) && typeof opts.fs.statSync === \"function\") {\n            this.fs = opts.fs;\n        }\n    }\n}\n\nmodule.exports = Utils;\n\n// INSTANCED functions\n\nUtils.prototype.makeDir = function (/*String*/ folder) {\n    const self = this;\n\n    // Sync - make directories tree\n    function mkdirSync(/*String*/ fpath) {\n        let resolvedPath = fpath.split(self.sep)[0];\n        fpath.split(self.sep).forEach(function (name) {\n            if (!name || name.substr(-1, 1) === \":\") return;\n            resolvedPath += self.sep + name;\n            var stat;\n            try {\n                stat = self.fs.statSync(resolvedPath);\n            } catch (e) {\n                self.fs.mkdirSync(resolvedPath);\n            }\n            if (stat && stat.isFile()) throw Errors.FILE_IN_THE_WAY.replace(\"%s\", resolvedPath);\n        });\n    }\n\n    mkdirSync(folder);\n};\n\nUtils.prototype.writeFileTo = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr) {\n    const self = this;\n    if (self.fs.existsSync(path)) {\n        if (!overwrite) return false; // cannot overwrite\n\n        var stat = self.fs.statSync(path);\n        if (stat.isDirectory()) {\n            return false;\n        }\n    }\n    var folder = pth.dirname(path);\n    if (!self.fs.existsSync(folder)) {\n        self.makeDir(folder);\n    }\n\n    var fd;\n    try {\n        fd = self.fs.openSync(path, \"w\", 438); // 0666\n    } catch (e) {\n        self.fs.chmodSync(path, 438);\n        fd = self.fs.openSync(path, \"w\", 438);\n    }\n    if (fd) {\n        try {\n            self.fs.writeSync(fd, content, 0, content.length, 0);\n        } finally {\n            self.fs.closeSync(fd);\n        }\n    }\n    self.fs.chmodSync(path, attr || 438);\n    return true;\n};\n\nUtils.prototype.writeFileToAsync = function (/*String*/ path, /*Buffer*/ content, /*Boolean*/ overwrite, /*Number*/ attr, /*Function*/ callback) {\n    if (typeof attr === \"function\") {\n        callback = attr;\n        attr = undefined;\n    }\n\n    const self = this;\n\n    self.fs.exists(path, function (exist) {\n        if (exist && !overwrite) return callback(false);\n\n        self.fs.stat(path, function (err, stat) {\n            if (exist && stat.isDirectory()) {\n                return callback(false);\n            }\n\n            var folder = pth.dirname(path);\n            self.fs.exists(folder, function (exists) {\n                if (!exists) self.makeDir(folder);\n\n                self.fs.open(path, \"w\", 438, function (err, fd) {\n                    if (err) {\n                        self.fs.chmod(path, 438, function () {\n                            self.fs.open(path, \"w\", 438, function (err, fd) {\n                                self.fs.write(fd, content, 0, content.length, 0, function () {\n                                    self.fs.close(fd, function () {\n                                        self.fs.chmod(path, attr || 438, function () {\n                                            callback(true);\n                                        });\n                                    });\n                                });\n                            });\n                        });\n                    } else if (fd) {\n                        self.fs.write(fd, content, 0, content.length, 0, function () {\n                            self.fs.close(fd, function () {\n                                self.fs.chmod(path, attr || 438, function () {\n                                    callback(true);\n                                });\n                            });\n                        });\n                    } else {\n                        self.fs.chmod(path, attr || 438, function () {\n                            callback(true);\n                        });\n                    }\n                });\n            });\n        });\n    });\n};\n\nUtils.prototype.findFiles = function (/*String*/ path) {\n    const self = this;\n\n    function findSync(/*String*/ dir, /*RegExp*/ pattern, /*Boolean*/ recursive) {\n        if (typeof pattern === \"boolean\") {\n            recursive = pattern;\n            pattern = undefined;\n        }\n        let files = [];\n        self.fs.readdirSync(dir).forEach(function (file) {\n            var path = pth.join(dir, file);\n\n            if (self.fs.statSync(path).isDirectory() && recursive) files = files.concat(findSync(path, pattern, recursive));\n\n            if (!pattern || pattern.test(path)) {\n                files.push(pth.normalize(path) + (self.fs.statSync(path).isDirectory() ? self.sep : \"\"));\n            }\n        });\n        return files;\n    }\n\n    return findSync(path, undefined, true);\n};\n\nUtils.prototype.getAttributes = function () {};\n\nUtils.prototype.setAttributes = function () {};\n\n// STATIC functions\n\n// crc32 single update (it is part of crc32)\nUtils.crc32update = function (crc, byte) {\n    return crcTable[(crc ^ byte) & 0xff] ^ (crc >>> 8);\n};\n\nUtils.crc32 = function (buf) {\n    if (typeof buf === \"string\") {\n        buf = Buffer.from(buf, \"utf8\");\n    }\n    // Generate crcTable\n    if (!crcTable.length) genCRCTable();\n\n    let len = buf.length;\n    let crc = ~0;\n    for (let off = 0; off < len; ) crc = Utils.crc32update(crc, buf[off++]);\n    // xor and cast as uint32 number\n    return ~crc >>> 0;\n};\n\nUtils.methodToString = function (/*Number*/ method) {\n    switch (method) {\n        case Constants.STORED:\n            return \"STORED (\" + method + \")\";\n        case Constants.DEFLATED:\n            return \"DEFLATED (\" + method + \")\";\n        default:\n            return \"UNSUPPORTED (\" + method + \")\";\n    }\n};\n\n// removes \"..\" style path elements\nUtils.canonical = function (/*string*/ path) {\n    if (!path) return \"\";\n    // trick normalize think path is absolute\n    var safeSuffix = pth.posix.normalize(\"/\" + path.split(\"\\\\\").join(\"/\"));\n    return pth.join(\".\", safeSuffix);\n};\n\n// make abolute paths taking prefix as root folder\nUtils.sanitize = function (/*string*/ prefix, /*string*/ name) {\n    prefix = pth.resolve(pth.normalize(prefix));\n    var parts = name.split(\"/\");\n    for (var i = 0, l = parts.length; i < l; i++) {\n        var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));\n        if (path.indexOf(prefix) === 0) {\n            return path;\n        }\n    }\n    return pth.normalize(pth.join(prefix, pth.basename(name)));\n};\n\n// converts buffer, Uint8Array, string types to buffer\nUtils.toBuffer = function toBuffer(/*buffer, Uint8Array, string*/ input) {\n    if (Buffer.isBuffer(input)) {\n        return input;\n    } else if (input instanceof Uint8Array) {\n        return Buffer.from(input);\n    } else {\n        // expect string all other values are invalid and return empty buffer\n        return typeof input === \"string\" ? Buffer.from(input, \"utf8\") : Buffer.alloc(0);\n    }\n};\n\nUtils.readBigUInt64LE = function (/*Buffer*/ buffer, /*int*/ index) {\n    var slice = Buffer.from(buffer.slice(index, index + 8));\n    slice.swap64();\n\n    return parseInt(`0x${slice.toString(\"hex\")}`);\n};\n\nUtils.isWin = isWin; // Do we have windows system\nUtils.crcTable = crcTable;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}