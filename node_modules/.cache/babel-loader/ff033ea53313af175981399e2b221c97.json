{"ast":null,"code":"/**\n * Archiver Core\n *\n * @ignore\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\n */\nvar fs = require('fs');\n\nvar glob = require('readdir-glob');\n\nvar async = require('async');\n\nvar path = require('path');\n\nvar util = require('archiver-utils');\n\nvar inherits = require('util').inherits;\n\nvar ArchiverError = require('./error');\n\nvar Transform = require('readable-stream').Transform;\n\nvar win32 = process.platform === 'win32';\n/**\n * @constructor\n * @param {String} format The archive format to use.\n * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.\n */\n\nvar Archiver = function Archiver(format, options) {\n  if (!(this instanceof Archiver)) {\n    return new Archiver(format, options);\n  }\n\n  if (typeof format !== 'string') {\n    options = format;\n    format = 'zip';\n  }\n\n  options = this.options = util.defaults(options, {\n    highWaterMark: 1024 * 1024,\n    statConcurrency: 4\n  });\n  Transform.call(this, options);\n  this._format = false;\n  this._module = false;\n  this._pending = 0;\n  this._pointer = 0;\n  this._entriesCount = 0;\n  this._entriesProcessedCount = 0;\n  this._fsEntriesTotalBytes = 0;\n  this._fsEntriesProcessedBytes = 0;\n  this._queue = async.queue(this._onQueueTask.bind(this), 1);\n\n  this._queue.drain(this._onQueueDrain.bind(this));\n\n  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);\n\n  this._statQueue.drain(this._onQueueDrain.bind(this));\n\n  this._state = {\n    aborted: false,\n    finalize: false,\n    finalizing: false,\n    finalized: false,\n    modulePiped: false\n  };\n  this._streams = [];\n};\n\ninherits(Archiver, Transform);\n/**\n * Internal logic for `abort`.\n *\n * @private\n * @return void\n */\n\nArchiver.prototype._abort = function () {\n  this._state.aborted = true;\n\n  this._queue.kill();\n\n  this._statQueue.kill();\n\n  if (this._queue.idle()) {\n    this._shutdown();\n  }\n};\n/**\n * Internal helper for appending files.\n *\n * @private\n * @param  {String} filepath The source filepath.\n * @param  {EntryData} data The entry data.\n * @return void\n */\n\n\nArchiver.prototype._append = function (filepath, data) {\n  data = data || {};\n  var task = {\n    source: null,\n    filepath: filepath\n  };\n\n  if (!data.name) {\n    data.name = filepath;\n  }\n\n  data.sourcePath = filepath;\n  task.data = data;\n  this._entriesCount++;\n\n  if (data.stats && data.stats instanceof fs.Stats) {\n    task = this._updateQueueTaskWithStats(task, data.stats);\n\n    if (task) {\n      if (data.stats.size) {\n        this._fsEntriesTotalBytes += data.stats.size;\n      }\n\n      this._queue.push(task);\n    }\n  } else {\n    this._statQueue.push(task);\n  }\n};\n/**\n * Internal logic for `finalize`.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._finalize = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n\n  this._state.finalizing = true;\n\n  this._moduleFinalize();\n\n  this._state.finalizing = false;\n  this._state.finalized = true;\n};\n/**\n * Checks the various state variables to determine if we can `finalize`.\n *\n * @private\n * @return {Boolean}\n */\n\n\nArchiver.prototype._maybeFinalize = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return false;\n  }\n\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n\n    return true;\n  }\n\n  return false;\n};\n/**\n * Appends an entry to the module.\n *\n * @private\n * @fires  Archiver#entry\n * @param  {(Buffer|Stream)} source\n * @param  {EntryData} data\n * @param  {Function} callback\n * @return void\n */\n\n\nArchiver.prototype._moduleAppend = function (source, data, callback) {\n  if (this._state.aborted) {\n    callback();\n    return;\n  }\n\n  this._module.append(source, data, function (err) {\n    this._task = null;\n\n    if (this._state.aborted) {\n      this._shutdown();\n\n      return;\n    }\n\n    if (err) {\n      this.emit('error', err);\n      setImmediate(callback);\n      return;\n    }\n    /**\n     * Fires when the entry's input has been processed and appended to the archive.\n     *\n     * @event Archiver#entry\n     * @type {EntryData}\n     */\n\n\n    this.emit('entry', data);\n    this._entriesProcessedCount++;\n\n    if (data.stats && data.stats.size) {\n      this._fsEntriesProcessedBytes += data.stats.size;\n    }\n    /**\n     * @event Archiver#progress\n     * @type {ProgressData}\n     */\n\n\n    this.emit('progress', {\n      entries: {\n        total: this._entriesCount,\n        processed: this._entriesProcessedCount\n      },\n      fs: {\n        totalBytes: this._fsEntriesTotalBytes,\n        processedBytes: this._fsEntriesProcessedBytes\n      }\n    });\n    setImmediate(callback);\n  }.bind(this));\n};\n/**\n * Finalizes the module.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._moduleFinalize = function () {\n  if (typeof this._module.finalize === 'function') {\n    this._module.finalize();\n  } else if (typeof this._module.end === 'function') {\n    this._module.end();\n  } else {\n    this.emit('error', new ArchiverError('NOENDMETHOD'));\n  }\n};\n/**\n * Pipes the module to our internal stream with error bubbling.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._modulePipe = function () {\n  this._module.on('error', this._onModuleError.bind(this));\n\n  this._module.pipe(this);\n\n  this._state.modulePiped = true;\n};\n/**\n * Determines if the current module supports a defined feature.\n *\n * @private\n * @param  {String} key\n * @return {Boolean}\n */\n\n\nArchiver.prototype._moduleSupports = function (key) {\n  if (!this._module.supports || !this._module.supports[key]) {\n    return false;\n  }\n\n  return this._module.supports[key];\n};\n/**\n * Unpipes the module from our internal stream.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._moduleUnpipe = function () {\n  this._module.unpipe(this);\n\n  this._state.modulePiped = false;\n};\n/**\n * Normalizes entry data with fallbacks for key properties.\n *\n * @private\n * @param  {Object} data\n * @param  {fs.Stats} stats\n * @return {Object}\n */\n\n\nArchiver.prototype._normalizeEntryData = function (data, stats) {\n  data = util.defaults(data, {\n    type: 'file',\n    name: null,\n    date: null,\n    mode: null,\n    prefix: null,\n    sourcePath: null,\n    stats: false\n  });\n\n  if (stats && data.stats === false) {\n    data.stats = stats;\n  }\n\n  var isDir = data.type === 'directory';\n\n  if (data.name) {\n    if (typeof data.prefix === 'string' && '' !== data.prefix) {\n      data.name = data.prefix + '/' + data.name;\n      data.prefix = null;\n    }\n\n    data.name = util.sanitizePath(data.name);\n\n    if (data.type !== 'symlink' && data.name.slice(-1) === '/') {\n      isDir = true;\n      data.type = 'directory';\n    } else if (isDir) {\n      data.name += '/';\n    }\n  } // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644\n\n\n  if (typeof data.mode === 'number') {\n    if (win32) {\n      data.mode &= 511;\n    } else {\n      data.mode &= 4095;\n    }\n  } else if (data.stats && data.mode === null) {\n    if (win32) {\n      data.mode = data.stats.mode & 511;\n    } else {\n      data.mode = data.stats.mode & 4095;\n    } // stat isn't reliable on windows; force 0755 for dir\n\n\n    if (win32 && isDir) {\n      data.mode = 493;\n    }\n  } else if (data.mode === null) {\n    data.mode = isDir ? 493 : 420;\n  }\n\n  if (data.stats && data.date === null) {\n    data.date = data.stats.mtime;\n  } else {\n    data.date = util.dateify(data.date);\n  }\n\n  return data;\n};\n/**\n * Error listener that re-emits error on to our internal stream.\n *\n * @private\n * @param  {Error} err\n * @return void\n */\n\n\nArchiver.prototype._onModuleError = function (err) {\n  /**\n   * @event Archiver#error\n   * @type {ErrorData}\n   */\n  this.emit('error', err);\n};\n/**\n * Checks the various state variables after queue has drained to determine if\n * we need to `finalize`.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._onQueueDrain = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n};\n/**\n * Appends each queue task to the module.\n *\n * @private\n * @param  {Object} task\n * @param  {Function} callback\n * @return void\n */\n\n\nArchiver.prototype._onQueueTask = function (task, callback) {\n  var fullCallback = function fullCallback() {\n    if (task.data.callback) {\n      task.data.callback();\n    }\n\n    callback();\n  };\n\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    fullCallback();\n    return;\n  }\n\n  this._task = task;\n\n  this._moduleAppend(task.source, task.data, fullCallback);\n};\n/**\n * Performs a file stat and reinjects the task back into the queue.\n *\n * @private\n * @param  {Object} task\n * @param  {Function} callback\n * @return void\n */\n\n\nArchiver.prototype._onStatQueueTask = function (task, callback) {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    callback();\n    return;\n  }\n\n  fs.lstat(task.filepath, function (err, stats) {\n    if (this._state.aborted) {\n      setImmediate(callback);\n      return;\n    }\n\n    if (err) {\n      this._entriesCount--;\n      /**\n       * @event Archiver#warning\n       * @type {ErrorData}\n       */\n\n      this.emit('warning', err);\n      setImmediate(callback);\n      return;\n    }\n\n    task = this._updateQueueTaskWithStats(task, stats);\n\n    if (task) {\n      if (stats.size) {\n        this._fsEntriesTotalBytes += stats.size;\n      }\n\n      this._queue.push(task);\n    }\n\n    setImmediate(callback);\n  }.bind(this));\n};\n/**\n * Unpipes the module and ends our internal stream.\n *\n * @private\n * @return void\n */\n\n\nArchiver.prototype._shutdown = function () {\n  this._moduleUnpipe();\n\n  this.end();\n};\n/**\n * Tracks the bytes emitted by our internal stream.\n *\n * @private\n * @param  {Buffer} chunk\n * @param  {String} encoding\n * @param  {Function} callback\n * @return void\n */\n\n\nArchiver.prototype._transform = function (chunk, encoding, callback) {\n  if (chunk) {\n    this._pointer += chunk.length;\n  }\n\n  callback(null, chunk);\n};\n/**\n * Updates and normalizes a queue task using stats data.\n *\n * @private\n * @param  {Object} task\n * @param  {fs.Stats} stats\n * @return {Object}\n */\n\n\nArchiver.prototype._updateQueueTaskWithStats = function (task, stats) {\n  if (stats.isFile()) {\n    task.data.type = 'file';\n    task.data.sourceType = 'stream';\n    task.source = util.lazyReadStream(task.filepath);\n  } else if (stats.isDirectory() && this._moduleSupports('directory')) {\n    task.data.name = util.trailingSlashIt(task.data.name);\n    task.data.type = 'directory';\n    task.data.sourcePath = util.trailingSlashIt(task.filepath);\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else if (stats.isSymbolicLink() && this._moduleSupports('symlink')) {\n    var linkPath = fs.readlinkSync(task.filepath);\n    var dirName = path.dirname(task.filepath);\n    task.data.type = 'symlink';\n    task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else {\n    if (stats.isDirectory()) {\n      this.emit('warning', new ArchiverError('DIRECTORYNOTSUPPORTED', task.data));\n    } else if (stats.isSymbolicLink()) {\n      this.emit('warning', new ArchiverError('SYMLINKNOTSUPPORTED', task.data));\n    } else {\n      this.emit('warning', new ArchiverError('ENTRYNOTSUPPORTED', task.data));\n    }\n\n    return null;\n  }\n\n  task.data = this._normalizeEntryData(task.data, stats);\n  return task;\n};\n/**\n * Aborts the archiving process, taking a best-effort approach, by:\n *\n * - removing any pending queue tasks\n * - allowing any active queue workers to finish\n * - detaching internal module pipes\n * - ending both sides of the Transform stream\n *\n * It will NOT drain any remaining sources.\n *\n * @return {this}\n */\n\n\nArchiver.prototype.abort = function () {\n  if (this._state.aborted || this._state.finalized) {\n    return this;\n  }\n\n  this._abort();\n\n  return this;\n};\n/**\n * Appends an input source (text string, buffer, or stream) to the instance.\n *\n * When the instance has received, processed, and emitted the input, the `entry`\n * event is fired.\n *\n * @fires  Archiver#entry\n * @param  {(Buffer|Stream|String)} source The input source.\n * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.\n * @return {this}\n */\n\n\nArchiver.prototype.append = function (source, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  data = this._normalizeEntryData(data);\n\n  if (typeof data.name !== 'string' || data.name.length === 0) {\n    this.emit('error', new ArchiverError('ENTRYNAMEREQUIRED'));\n    return this;\n  }\n\n  if (data.type === 'directory' && !this._moduleSupports('directory')) {\n    this.emit('error', new ArchiverError('DIRECTORYNOTSUPPORTED', {\n      name: data.name\n    }));\n    return this;\n  }\n\n  source = util.normalizeInputSource(source);\n\n  if (Buffer.isBuffer(source)) {\n    data.sourceType = 'buffer';\n  } else if (util.isStream(source)) {\n    data.sourceType = 'stream';\n  } else {\n    this.emit('error', new ArchiverError('INPUTSTEAMBUFFERREQUIRED', {\n      name: data.name\n    }));\n    return this;\n  }\n\n  this._entriesCount++;\n\n  this._queue.push({\n    data: data,\n    source: source\n  });\n\n  return this;\n};\n/**\n * Appends a directory and its files, recursively, given its dirpath.\n *\n * @param  {String} dirpath The source directory path.\n * @param  {String} destpath The destination path within the archive.\n * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\n\n\nArchiver.prototype.directory = function (dirpath, destpath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof dirpath !== 'string' || dirpath.length === 0) {\n    this.emit('error', new ArchiverError('DIRECTORYDIRPATHREQUIRED'));\n    return this;\n  }\n\n  this._pending++;\n\n  if (destpath === false) {\n    destpath = '';\n  } else if (typeof destpath !== 'string') {\n    destpath = dirpath;\n  }\n\n  var dataFunction = false;\n\n  if (typeof data === 'function') {\n    dataFunction = data;\n    data = {};\n  } else if (typeof data !== 'object') {\n    data = {};\n  }\n\n  var globOptions = {\n    stat: true,\n    dot: true\n  };\n\n  function onGlobEnd() {\n    this._pending--;\n\n    this._maybeFinalize();\n  }\n\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n\n  function onGlobMatch(match) {\n    globber.pause();\n    var ignoreMatch = false;\n    var entryData = Object.assign({}, data);\n    entryData.name = match.relative;\n    entryData.prefix = destpath;\n    entryData.stats = match.stat;\n    entryData.callback = globber.resume.bind(globber);\n\n    try {\n      if (dataFunction) {\n        entryData = dataFunction(entryData);\n\n        if (entryData === false) {\n          ignoreMatch = true;\n        } else if (typeof entryData !== 'object') {\n          throw new ArchiverError('DIRECTORYFUNCTIONINVALIDDATA', {\n            dirpath: dirpath\n          });\n        }\n      }\n    } catch (e) {\n      this.emit('error', e);\n      return;\n    }\n\n    if (ignoreMatch) {\n      globber.resume();\n      return;\n    }\n\n    this._append(match.absolute, entryData);\n  }\n\n  var globber = glob(dirpath, globOptions);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n  return this;\n};\n/**\n * Appends a file given its filepath using a\n * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to\n * prevent issues with open file limits.\n *\n * When the instance has received, processed, and emitted the file, the `entry`\n * event is fired.\n *\n * @param  {String} filepath The source filepath.\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\n\n\nArchiver.prototype.file = function (filepath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('FILEFILEPATHREQUIRED'));\n    return this;\n  }\n\n  this._append(filepath, data);\n\n  return this;\n};\n/**\n * Appends multiple files that match a glob pattern.\n *\n * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/minimatch} to match.\n * @param  {Object} options See [node-readdir-glob]{@link https://github.com/yqnn/node-readdir-glob#options}.\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\n\n\nArchiver.prototype.glob = function (pattern, options, data) {\n  this._pending++;\n  options = util.defaults(options, {\n    stat: true,\n    pattern: pattern\n  });\n\n  function onGlobEnd() {\n    this._pending--;\n\n    this._maybeFinalize();\n  }\n\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n\n  function onGlobMatch(match) {\n    globber.pause();\n    var entryData = Object.assign({}, data);\n    entryData.callback = globber.resume.bind(globber);\n    entryData.stats = match.stat;\n    entryData.name = match.relative;\n\n    this._append(match.absolute, entryData);\n  }\n\n  var globber = glob(options.cwd || '.', options);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n  return this;\n};\n/**\n * Finalizes the instance and prevents further appending to the archive\n * structure (queue will continue til drained).\n *\n * The `end`, `close` or `finish` events on the destination stream may fire\n * right after calling this method so you should set listeners beforehand to\n * properly detect stream completion.\n *\n * @return {Promise}\n */\n\n\nArchiver.prototype.finalize = function () {\n  if (this._state.aborted) {\n    var abortedError = new ArchiverError('ABORTED');\n    this.emit('error', abortedError);\n    return Promise.reject(abortedError);\n  }\n\n  if (this._state.finalize) {\n    var finalizingError = new ArchiverError('FINALIZING');\n    this.emit('error', finalizingError);\n    return Promise.reject(finalizingError);\n  }\n\n  this._state.finalize = true;\n\n  if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    var errored;\n\n    self._module.on('end', function () {\n      if (!errored) {\n        resolve();\n      }\n    });\n\n    self._module.on('error', function (err) {\n      errored = true;\n      reject(err);\n    });\n  });\n};\n/**\n * Sets the module format name used for archiving.\n *\n * @param {String} format The name of the format.\n * @return {this}\n */\n\n\nArchiver.prototype.setFormat = function (format) {\n  if (this._format) {\n    this.emit('error', new ArchiverError('FORMATSET'));\n    return this;\n  }\n\n  this._format = format;\n  return this;\n};\n/**\n * Sets the module used for archiving.\n *\n * @param {Function} module The function for archiver to interact with.\n * @return {this}\n */\n\n\nArchiver.prototype.setModule = function (module) {\n  if (this._state.aborted) {\n    this.emit('error', new ArchiverError('ABORTED'));\n    return this;\n  }\n\n  if (this._state.module) {\n    this.emit('error', new ArchiverError('MODULESET'));\n    return this;\n  }\n\n  this._module = module;\n\n  this._modulePipe();\n\n  return this;\n};\n/**\n * Appends a symlink to the instance.\n *\n * This does NOT interact with filesystem and is used for programmatically creating symlinks.\n *\n * @param  {String} filepath The symlink path (within archive).\n * @param  {String} target The target path (within archive).\n * @param  {Number} mode Sets the entry permissions.\n * @return {this}\n */\n\n\nArchiver.prototype.symlink = function (filepath, target, mode) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKFILEPATHREQUIRED'));\n    return this;\n  }\n\n  if (typeof target !== 'string' || target.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKTARGETREQUIRED', {\n      filepath: filepath\n    }));\n    return this;\n  }\n\n  if (!this._moduleSupports('symlink')) {\n    this.emit('error', new ArchiverError('SYMLINKNOTSUPPORTED', {\n      filepath: filepath\n    }));\n    return this;\n  }\n\n  var data = {};\n  data.type = 'symlink';\n  data.name = filepath.replace(/\\\\/g, '/');\n  data.linkname = target.replace(/\\\\/g, '/');\n  data.sourceType = 'buffer';\n\n  if (typeof mode === \"number\") {\n    data.mode = mode;\n  }\n\n  this._entriesCount++;\n\n  this._queue.push({\n    data: data,\n    source: Buffer.concat([])\n  });\n\n  return this;\n};\n/**\n * Returns the current length (in bytes) that has been emitted.\n *\n * @return {Number}\n */\n\n\nArchiver.prototype.pointer = function () {\n  return this._pointer;\n};\n/**\n * Middleware-like helper that has yet to be fully implemented.\n *\n * @private\n * @param  {Function} plugin\n * @return {this}\n */\n\n\nArchiver.prototype.use = function (plugin) {\n  this._streams.push(plugin);\n\n  return this;\n};\n\nmodule.exports = Archiver;\n/**\n * @typedef {Object} CoreOptions\n * @global\n * @property {Number} [statConcurrency=4] Sets the number of workers used to\n * process the internal fs stat queue.\n */\n\n/**\n * @typedef {Object} TransformOptions\n * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream\n * will automatically end the readable side when the writable side ends and vice\n * versa.\n * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable\n * side of the stream. Has no effect if objectMode is true.\n * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable\n * side of the stream. Has no effect if objectMode is true.\n * @property {Boolean} [decodeStrings=true] Whether or not to decode strings\n * into Buffers before passing them to _write(). `Writable`\n * @property {String} [encoding=NULL] If specified, then buffers will be decoded\n * to strings using the specified encoding. `Readable`\n * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store\n * in the internal buffer before ceasing to read from the underlying resource.\n * `Readable` `Writable`\n * @property {Boolean} [objectMode=false] Whether this stream should behave as a\n * stream of objects. Meaning that stream.read(n) returns a single value instead\n * of a Buffer of size n. `Readable` `Writable`\n */\n\n/**\n * @typedef {Object} EntryData\n * @property {String} name Sets the entry name including internal path.\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\n * when working with methods like `directory` or `glob`.\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\n * for reduction of fs stat calls when stat data is already known.\n */\n\n/**\n * @typedef {Object} ErrorData\n * @property {String} message The message of the error.\n * @property {String} code The error code assigned to this error.\n * @property {String} data Additional data provided for reporting or debugging (where available).\n */\n\n/**\n * @typedef {Object} ProgressData\n * @property {Object} entries\n * @property {Number} entries.total Number of entries that have been appended.\n * @property {Number} entries.processed Number of entries that have been processed.\n * @property {Object} fs\n * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)\n * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)\n */","map":{"version":3,"names":["fs","require","glob","async","path","util","inherits","ArchiverError","Transform","win32","process","platform","Archiver","format","options","defaults","highWaterMark","statConcurrency","call","_format","_module","_pending","_pointer","_entriesCount","_entriesProcessedCount","_fsEntriesTotalBytes","_fsEntriesProcessedBytes","_queue","queue","_onQueueTask","bind","drain","_onQueueDrain","_statQueue","_onStatQueueTask","_state","aborted","finalize","finalizing","finalized","modulePiped","_streams","prototype","_abort","kill","idle","_shutdown","_append","filepath","data","task","source","name","sourcePath","stats","Stats","_updateQueueTaskWithStats","size","push","_finalize","_moduleFinalize","_maybeFinalize","_moduleAppend","callback","append","err","_task","emit","setImmediate","entries","total","processed","totalBytes","processedBytes","end","_modulePipe","on","_onModuleError","pipe","_moduleSupports","key","supports","_moduleUnpipe","unpipe","_normalizeEntryData","type","date","mode","prefix","isDir","sanitizePath","slice","mtime","dateify","fullCallback","lstat","_transform","chunk","encoding","length","isFile","sourceType","lazyReadStream","isDirectory","trailingSlashIt","Buffer","concat","isSymbolicLink","linkPath","readlinkSync","dirName","dirname","linkname","relative","resolve","abort","normalizeInputSource","isBuffer","isStream","directory","dirpath","destpath","dataFunction","globOptions","stat","dot","onGlobEnd","onGlobError","onGlobMatch","match","globber","pause","ignoreMatch","entryData","Object","assign","resume","e","absolute","file","pattern","cwd","abortedError","Promise","reject","finalizingError","self","errored","setFormat","setModule","module","symlink","target","replace","pointer","use","plugin","exports"],"sources":["/Users/andrejsmolencev/Desktop/scorm-generator/node_modules/archiver/lib/core.js"],"sourcesContent":["/**\n * Archiver Core\n *\n * @ignore\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\n */\nvar fs = require('fs');\nvar glob = require('readdir-glob');\nvar async = require('async');\nvar path = require('path');\nvar util = require('archiver-utils');\n\nvar inherits = require('util').inherits;\nvar ArchiverError = require('./error');\nvar Transform = require('readable-stream').Transform;\n\nvar win32 = process.platform === 'win32';\n\n/**\n * @constructor\n * @param {String} format The archive format to use.\n * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.\n */\nvar Archiver = function(format, options) {\n  if (!(this instanceof Archiver)) {\n    return new Archiver(format, options);\n  }\n\n  if (typeof format !== 'string') {\n    options = format;\n    format = 'zip';\n  }\n\n  options = this.options = util.defaults(options, {\n    highWaterMark: 1024 * 1024,\n    statConcurrency: 4\n  });\n\n  Transform.call(this, options);\n\n  this._format = false;\n  this._module = false;\n  this._pending = 0;\n  this._pointer = 0;\n\n  this._entriesCount = 0;\n  this._entriesProcessedCount = 0;\n  this._fsEntriesTotalBytes = 0;\n  this._fsEntriesProcessedBytes = 0;\n\n  this._queue = async.queue(this._onQueueTask.bind(this), 1);\n  this._queue.drain(this._onQueueDrain.bind(this));\n\n  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);\n  this._statQueue.drain(this._onQueueDrain.bind(this));\n\n  this._state = {\n    aborted: false,\n    finalize: false,\n    finalizing: false,\n    finalized: false,\n    modulePiped: false\n  };\n\n  this._streams = [];\n};\n\ninherits(Archiver, Transform);\n\n/**\n * Internal logic for `abort`.\n *\n * @private\n * @return void\n */\nArchiver.prototype._abort = function() {\n  this._state.aborted = true;\n  this._queue.kill();\n  this._statQueue.kill();\n\n  if (this._queue.idle()) {\n    this._shutdown();\n  }\n};\n\n/**\n * Internal helper for appending files.\n *\n * @private\n * @param  {String} filepath The source filepath.\n * @param  {EntryData} data The entry data.\n * @return void\n */\nArchiver.prototype._append = function(filepath, data) {\n  data = data || {};\n\n  var task = {\n    source: null,\n    filepath: filepath\n  };\n\n  if (!data.name) {\n    data.name = filepath;\n  }\n\n  data.sourcePath = filepath;\n  task.data = data;\n  this._entriesCount++;\n\n  if (data.stats && data.stats instanceof fs.Stats) {\n    task = this._updateQueueTaskWithStats(task, data.stats);\n    if (task) {\n      if (data.stats.size) {\n        this._fsEntriesTotalBytes += data.stats.size;\n      }\n\n      this._queue.push(task);\n    }\n  } else {\n    this._statQueue.push(task);\n  }\n};\n\n/**\n * Internal logic for `finalize`.\n *\n * @private\n * @return void\n */\nArchiver.prototype._finalize = function() {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n\n  this._state.finalizing = true;\n\n  this._moduleFinalize();\n\n  this._state.finalizing = false;\n  this._state.finalized = true;\n};\n\n/**\n * Checks the various state variables to determine if we can `finalize`.\n *\n * @private\n * @return {Boolean}\n */\nArchiver.prototype._maybeFinalize = function() {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return false;\n  }\n\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Appends an entry to the module.\n *\n * @private\n * @fires  Archiver#entry\n * @param  {(Buffer|Stream)} source\n * @param  {EntryData} data\n * @param  {Function} callback\n * @return void\n */\nArchiver.prototype._moduleAppend = function(source, data, callback) {\n  if (this._state.aborted) {\n    callback();\n    return;\n  }\n\n  this._module.append(source, data, function(err) {\n    this._task = null;\n\n    if (this._state.aborted) {\n      this._shutdown();\n      return;\n    }\n\n    if (err) {\n      this.emit('error', err);\n      setImmediate(callback);\n      return;\n    }\n\n    /**\n     * Fires when the entry's input has been processed and appended to the archive.\n     *\n     * @event Archiver#entry\n     * @type {EntryData}\n     */\n    this.emit('entry', data);\n    this._entriesProcessedCount++;\n\n    if (data.stats && data.stats.size) {\n      this._fsEntriesProcessedBytes += data.stats.size;\n    }\n\n    /**\n     * @event Archiver#progress\n     * @type {ProgressData}\n     */\n    this.emit('progress', {\n      entries: {\n        total: this._entriesCount,\n        processed: this._entriesProcessedCount\n      },\n      fs: {\n        totalBytes: this._fsEntriesTotalBytes,\n        processedBytes: this._fsEntriesProcessedBytes\n      }\n    });\n\n    setImmediate(callback);\n  }.bind(this));\n};\n\n/**\n * Finalizes the module.\n *\n * @private\n * @return void\n */\nArchiver.prototype._moduleFinalize = function() {\n  if (typeof this._module.finalize === 'function') {\n    this._module.finalize();\n  } else if (typeof this._module.end === 'function') {\n    this._module.end();\n  } else {\n    this.emit('error', new ArchiverError('NOENDMETHOD'));\n  }\n};\n\n/**\n * Pipes the module to our internal stream with error bubbling.\n *\n * @private\n * @return void\n */\nArchiver.prototype._modulePipe = function() {\n  this._module.on('error', this._onModuleError.bind(this));\n  this._module.pipe(this);\n  this._state.modulePiped = true;\n};\n\n/**\n * Determines if the current module supports a defined feature.\n *\n * @private\n * @param  {String} key\n * @return {Boolean}\n */\nArchiver.prototype._moduleSupports = function(key) {\n  if (!this._module.supports || !this._module.supports[key]) {\n    return false;\n  }\n\n  return this._module.supports[key];\n};\n\n/**\n * Unpipes the module from our internal stream.\n *\n * @private\n * @return void\n */\nArchiver.prototype._moduleUnpipe = function() {\n  this._module.unpipe(this);\n  this._state.modulePiped = false;\n};\n\n/**\n * Normalizes entry data with fallbacks for key properties.\n *\n * @private\n * @param  {Object} data\n * @param  {fs.Stats} stats\n * @return {Object}\n */\nArchiver.prototype._normalizeEntryData = function(data, stats) {\n  data = util.defaults(data, {\n    type: 'file',\n    name: null,\n    date: null,\n    mode: null,\n    prefix: null,\n    sourcePath: null,\n    stats: false\n  });\n\n  if (stats && data.stats === false) {\n    data.stats = stats;\n  }\n\n  var isDir = data.type === 'directory';\n\n  if (data.name) {\n    if (typeof data.prefix === 'string' && '' !== data.prefix) {\n      data.name = data.prefix + '/' + data.name;\n      data.prefix = null;\n    }\n\n    data.name = util.sanitizePath(data.name);\n\n    if (data.type !== 'symlink' && data.name.slice(-1) === '/') {\n      isDir = true;\n      data.type = 'directory';\n    } else if (isDir) {\n      data.name += '/';\n    }\n  }\n\n  // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644\n  if (typeof data.mode === 'number') {\n    if (win32) {\n      data.mode &= 511;\n    } else {\n      data.mode &= 4095\n    }\n  } else if (data.stats && data.mode === null) {\n    if (win32) {\n      data.mode = data.stats.mode & 511;\n    } else {\n      data.mode = data.stats.mode & 4095;\n    }\n\n    // stat isn't reliable on windows; force 0755 for dir\n    if (win32 && isDir) {\n      data.mode = 493;\n    }\n  } else if (data.mode === null) {\n    data.mode = isDir ? 493 : 420;\n  }\n\n  if (data.stats && data.date === null) {\n    data.date = data.stats.mtime;\n  } else {\n    data.date = util.dateify(data.date);\n  }\n\n  return data;\n};\n\n/**\n * Error listener that re-emits error on to our internal stream.\n *\n * @private\n * @param  {Error} err\n * @return void\n */\nArchiver.prototype._onModuleError = function(err) {\n  /**\n   * @event Archiver#error\n   * @type {ErrorData}\n   */\n  this.emit('error', err);\n};\n\n/**\n * Checks the various state variables after queue has drained to determine if\n * we need to `finalize`.\n *\n * @private\n * @return void\n */\nArchiver.prototype._onQueueDrain = function() {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n};\n\n/**\n * Appends each queue task to the module.\n *\n * @private\n * @param  {Object} task\n * @param  {Function} callback\n * @return void\n */\nArchiver.prototype._onQueueTask = function(task, callback) {\n  var fullCallback = () => {\n    if(task.data.callback) {\n      task.data.callback();\n    }\n    callback();\n  }\n\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    fullCallback();\n    return;\n  }\n\n  this._task = task;\n  this._moduleAppend(task.source, task.data, fullCallback);\n};\n\n/**\n * Performs a file stat and reinjects the task back into the queue.\n *\n * @private\n * @param  {Object} task\n * @param  {Function} callback\n * @return void\n */\nArchiver.prototype._onStatQueueTask = function(task, callback) {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    callback();\n    return;\n  }\n\n  fs.lstat(task.filepath, function(err, stats) {\n    if (this._state.aborted) {\n      setImmediate(callback);\n      return;\n    }\n\n    if (err) {\n      this._entriesCount--;\n\n      /**\n       * @event Archiver#warning\n       * @type {ErrorData}\n       */\n      this.emit('warning', err);\n      setImmediate(callback);\n      return;\n    }\n\n    task = this._updateQueueTaskWithStats(task, stats);\n\n    if (task) {\n      if (stats.size) {\n        this._fsEntriesTotalBytes += stats.size;\n      }\n\n      this._queue.push(task);\n    }\n\n    setImmediate(callback);\n  }.bind(this));\n};\n\n/**\n * Unpipes the module and ends our internal stream.\n *\n * @private\n * @return void\n */\nArchiver.prototype._shutdown = function() {\n  this._moduleUnpipe();\n  this.end();\n};\n\n/**\n * Tracks the bytes emitted by our internal stream.\n *\n * @private\n * @param  {Buffer} chunk\n * @param  {String} encoding\n * @param  {Function} callback\n * @return void\n */\nArchiver.prototype._transform = function(chunk, encoding, callback) {\n  if (chunk) {\n    this._pointer += chunk.length;\n  }\n\n  callback(null, chunk);\n};\n\n/**\n * Updates and normalizes a queue task using stats data.\n *\n * @private\n * @param  {Object} task\n * @param  {fs.Stats} stats\n * @return {Object}\n */\nArchiver.prototype._updateQueueTaskWithStats = function(task, stats) {\n  if (stats.isFile()) {\n    task.data.type = 'file';\n    task.data.sourceType = 'stream';\n    task.source = util.lazyReadStream(task.filepath);\n  } else if (stats.isDirectory() && this._moduleSupports('directory')) {\n    task.data.name = util.trailingSlashIt(task.data.name);\n    task.data.type = 'directory';\n    task.data.sourcePath = util.trailingSlashIt(task.filepath);\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else if (stats.isSymbolicLink() && this._moduleSupports('symlink')) {\n    var linkPath = fs.readlinkSync(task.filepath);\n    var dirName = path.dirname(task.filepath);\n    task.data.type = 'symlink';\n    task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else {\n    if (stats.isDirectory()) {\n      this.emit('warning', new ArchiverError('DIRECTORYNOTSUPPORTED', task.data));\n    } else if (stats.isSymbolicLink()) {\n      this.emit('warning', new ArchiverError('SYMLINKNOTSUPPORTED', task.data));\n    } else {\n      this.emit('warning', new ArchiverError('ENTRYNOTSUPPORTED', task.data));\n    }\n\n    return null;\n  }\n\n  task.data = this._normalizeEntryData(task.data, stats);\n\n  return task;\n};\n\n/**\n * Aborts the archiving process, taking a best-effort approach, by:\n *\n * - removing any pending queue tasks\n * - allowing any active queue workers to finish\n * - detaching internal module pipes\n * - ending both sides of the Transform stream\n *\n * It will NOT drain any remaining sources.\n *\n * @return {this}\n */\nArchiver.prototype.abort = function() {\n  if (this._state.aborted || this._state.finalized) {\n    return this;\n  }\n\n  this._abort();\n\n  return this;\n};\n\n/**\n * Appends an input source (text string, buffer, or stream) to the instance.\n *\n * When the instance has received, processed, and emitted the input, the `entry`\n * event is fired.\n *\n * @fires  Archiver#entry\n * @param  {(Buffer|Stream|String)} source The input source.\n * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.\n * @return {this}\n */\nArchiver.prototype.append = function(source, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  data = this._normalizeEntryData(data);\n\n  if (typeof data.name !== 'string' || data.name.length === 0) {\n    this.emit('error', new ArchiverError('ENTRYNAMEREQUIRED'));\n    return this;\n  }\n\n  if (data.type === 'directory' && !this._moduleSupports('directory')) {\n    this.emit('error', new ArchiverError('DIRECTORYNOTSUPPORTED', { name: data.name }));\n    return this;\n  }\n\n  source = util.normalizeInputSource(source);\n\n  if (Buffer.isBuffer(source)) {\n    data.sourceType = 'buffer';\n  } else if (util.isStream(source)) {\n    data.sourceType = 'stream';\n  } else {\n    this.emit('error', new ArchiverError('INPUTSTEAMBUFFERREQUIRED', { name: data.name }));\n    return this;\n  }\n\n  this._entriesCount++;\n  this._queue.push({\n    data: data,\n    source: source\n  });\n\n  return this;\n};\n\n/**\n * Appends a directory and its files, recursively, given its dirpath.\n *\n * @param  {String} dirpath The source directory path.\n * @param  {String} destpath The destination path within the archive.\n * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\nArchiver.prototype.directory = function(dirpath, destpath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof dirpath !== 'string' || dirpath.length === 0) {\n    this.emit('error', new ArchiverError('DIRECTORYDIRPATHREQUIRED'));\n    return this;\n  }\n\n  this._pending++;\n\n  if (destpath === false) {\n    destpath = '';\n  } else if (typeof destpath !== 'string'){\n    destpath = dirpath;\n  }\n\n  var dataFunction = false;\n  if (typeof data === 'function') {\n    dataFunction = data;\n    data = {};\n  } else if (typeof data !== 'object') {\n    data = {};\n  }\n\n  var globOptions = {\n    stat: true,\n    dot: true\n  };\n\n  function onGlobEnd() {\n    this._pending--;\n    this._maybeFinalize();\n  }\n\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n\n  function onGlobMatch(match){\n    globber.pause();\n\n    var ignoreMatch = false;\n    var entryData = Object.assign({}, data);\n    entryData.name = match.relative;\n    entryData.prefix = destpath;\n    entryData.stats = match.stat;\n    entryData.callback = globber.resume.bind(globber);\n\n    try {\n      if (dataFunction) {\n        entryData = dataFunction(entryData);\n\n        if (entryData === false) {\n          ignoreMatch = true;\n        } else if (typeof entryData !== 'object') {\n          throw new ArchiverError('DIRECTORYFUNCTIONINVALIDDATA', { dirpath: dirpath });\n        }\n      }\n    } catch(e) {\n      this.emit('error', e);\n      return;\n    }\n\n    if (ignoreMatch) {\n      globber.resume();\n      return;\n    }\n\n    this._append(match.absolute, entryData);\n  }\n\n  var globber = glob(dirpath, globOptions);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n\n  return this;\n};\n\n/**\n * Appends a file given its filepath using a\n * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to\n * prevent issues with open file limits.\n *\n * When the instance has received, processed, and emitted the file, the `entry`\n * event is fired.\n *\n * @param  {String} filepath The source filepath.\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\nArchiver.prototype.file = function(filepath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('FILEFILEPATHREQUIRED'));\n    return this;\n  }\n\n  this._append(filepath, data);\n\n  return this;\n};\n\n/**\n * Appends multiple files that match a glob pattern.\n *\n * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/minimatch} to match.\n * @param  {Object} options See [node-readdir-glob]{@link https://github.com/yqnn/node-readdir-glob#options}.\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\n * [TarEntryData]{@link TarEntryData}.\n * @return {this}\n */\nArchiver.prototype.glob = function(pattern, options, data) {\n  this._pending++;\n\n  options = util.defaults(options, {\n    stat: true,\n    pattern: pattern\n  });\n\n  function onGlobEnd() {\n    this._pending--;\n    this._maybeFinalize();\n  }\n\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n\n  function onGlobMatch(match){\n    globber.pause();\n    var entryData = Object.assign({}, data);\n    entryData.callback = globber.resume.bind(globber);\n    entryData.stats = match.stat;\n    entryData.name = match.relative;\n\n    this._append(match.absolute, entryData);\n  }\n\n  var globber = glob(options.cwd || '.', options);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n\n  return this;\n};\n\n/**\n * Finalizes the instance and prevents further appending to the archive\n * structure (queue will continue til drained).\n *\n * The `end`, `close` or `finish` events on the destination stream may fire\n * right after calling this method so you should set listeners beforehand to\n * properly detect stream completion.\n *\n * @return {Promise}\n */\nArchiver.prototype.finalize = function() {\n  if (this._state.aborted) {\n    var abortedError = new ArchiverError('ABORTED');\n    this.emit('error', abortedError);\n    return Promise.reject(abortedError);\n  }\n\n  if (this._state.finalize) {\n    var finalizingError = new ArchiverError('FINALIZING');\n    this.emit('error', finalizingError);\n    return Promise.reject(finalizingError);\n  }\n\n  this._state.finalize = true;\n\n  if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n\n  var self = this;\n\n  return new Promise(function(resolve, reject) {\n    var errored;\n\n    self._module.on('end', function() {\n      if (!errored) {\n        resolve();\n      }\n    })\n\n    self._module.on('error', function(err) {\n      errored = true;\n      reject(err);\n    })\n  })\n};\n\n/**\n * Sets the module format name used for archiving.\n *\n * @param {String} format The name of the format.\n * @return {this}\n */\nArchiver.prototype.setFormat = function(format) {\n  if (this._format) {\n    this.emit('error', new ArchiverError('FORMATSET'));\n    return this;\n  }\n\n  this._format = format;\n\n  return this;\n};\n\n/**\n * Sets the module used for archiving.\n *\n * @param {Function} module The function for archiver to interact with.\n * @return {this}\n */\nArchiver.prototype.setModule = function(module) {\n  if (this._state.aborted) {\n    this.emit('error', new ArchiverError('ABORTED'));\n    return this;\n  }\n\n  if (this._state.module) {\n    this.emit('error', new ArchiverError('MODULESET'));\n    return this;\n  }\n\n  this._module = module;\n  this._modulePipe();\n\n  return this;\n};\n\n/**\n * Appends a symlink to the instance.\n *\n * This does NOT interact with filesystem and is used for programmatically creating symlinks.\n *\n * @param  {String} filepath The symlink path (within archive).\n * @param  {String} target The target path (within archive).\n * @param  {Number} mode Sets the entry permissions.\n * @return {this}\n */\nArchiver.prototype.symlink = function(filepath, target, mode) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKFILEPATHREQUIRED'));\n    return this;\n  }\n\n  if (typeof target !== 'string' || target.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKTARGETREQUIRED', { filepath: filepath }));\n    return this;\n  }\n\n  if (!this._moduleSupports('symlink')) {\n    this.emit('error', new ArchiverError('SYMLINKNOTSUPPORTED', { filepath: filepath }));\n    return this;\n  }\n\n  var data = {};\n  data.type = 'symlink';\n  data.name = filepath.replace(/\\\\/g, '/');\n  data.linkname = target.replace(/\\\\/g, '/');\n  data.sourceType = 'buffer';\n\n  if (typeof mode === \"number\") {\n    data.mode = mode;\n  }\n\n  this._entriesCount++;\n  this._queue.push({\n    data: data,\n    source: Buffer.concat([])\n  });\n\n  return this;\n};\n\n/**\n * Returns the current length (in bytes) that has been emitted.\n *\n * @return {Number}\n */\nArchiver.prototype.pointer = function() {\n  return this._pointer;\n};\n\n/**\n * Middleware-like helper that has yet to be fully implemented.\n *\n * @private\n * @param  {Function} plugin\n * @return {this}\n */\nArchiver.prototype.use = function(plugin) {\n  this._streams.push(plugin);\n  return this;\n};\n\nmodule.exports = Archiver;\n\n/**\n * @typedef {Object} CoreOptions\n * @global\n * @property {Number} [statConcurrency=4] Sets the number of workers used to\n * process the internal fs stat queue.\n */\n\n/**\n * @typedef {Object} TransformOptions\n * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream\n * will automatically end the readable side when the writable side ends and vice\n * versa.\n * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable\n * side of the stream. Has no effect if objectMode is true.\n * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable\n * side of the stream. Has no effect if objectMode is true.\n * @property {Boolean} [decodeStrings=true] Whether or not to decode strings\n * into Buffers before passing them to _write(). `Writable`\n * @property {String} [encoding=NULL] If specified, then buffers will be decoded\n * to strings using the specified encoding. `Readable`\n * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store\n * in the internal buffer before ceasing to read from the underlying resource.\n * `Readable` `Writable`\n * @property {Boolean} [objectMode=false] Whether this stream should behave as a\n * stream of objects. Meaning that stream.read(n) returns a single value instead\n * of a Buffer of size n. `Readable` `Writable`\n */\n\n/**\n * @typedef {Object} EntryData\n * @property {String} name Sets the entry name including internal path.\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\n * when working with methods like `directory` or `glob`.\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\n * for reduction of fs stat calls when stat data is already known.\n */\n\n/**\n * @typedef {Object} ErrorData\n * @property {String} message The message of the error.\n * @property {String} code The error code assigned to this error.\n * @property {String} data Additional data provided for reporting or debugging (where available).\n */\n\n/**\n * @typedef {Object} ProgressData\n * @property {Object} entries\n * @property {Number} entries.total Number of entries that have been appended.\n * @property {Number} entries.processed Number of entries that have been processed.\n * @property {Object} fs\n * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)\n * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}